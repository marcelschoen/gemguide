= GEM Guide für AHCC

== Einführung

Dieses Dokument ist eine Anleitung zum schreiben von GEM Applikationen
in C mit AHCC. Sie enthält die detaillierten einzelnen Schritte zur
Implementation einer Beispiel GEM Anwendung. Das Beispiel-Programm
beginn zuerst mit einem einzelnen Fenster mit etwas Text. Dann erweitern wir
das Programm über mehrere Versionen hinweg, um mehrere Fenster mit
Schiebern und anderen Fenster-Widgets zu erzeugen. Das Programm wird
dann erweitert um Menüs, Datei-Dialoge und andere AES Features.

Wieso AHCC? Zwar gibt es viele Optionen für die C-Programmierung auf der
Atari Plattform, doch wird AHCC ständig aktualisiert, und es läuft nativ auf
(allen?) Atari computern und Clones. Es ist eine vollständige IDE, inklusive
eines Editors und eines Compilers und Linkers: Ich benutze dieses Programm
extensiv auf meiner FireBee, und ebenso auf meinem Atari STE. AHCC ist
verfügbar unter dieser URL: http://members.chello.nl/h.robbers/. Obwohl
für AHCC geschrieben, trifft das meiste folgende auch für andere C Compiler
für den Atari zu, aber die Beispiele müssen allenfalls in ihren
Header-, Projekt- und Make-Dateien angepasst werden.

Es gibt auch andere ähnliche Anleitungen da draussen; Ich habe auch
von der folgenden gehört, die CManShip benutzt, geschrieben von
Clayton Walnum, und verfügbar auf AtariForge:

* CManShip HYP http://dev-docs.atariforge.org/files/cmanship.hyp
* CManShip disk http://dev-docs.atariforge.org/files/cmanship.zip

Allerdings benötigen die Beispiele in CManShip einige Anpassungen, um
mit AHCC compiliert zu werden (meine angepassten Dateien für AHCC sind
verfügbar unter https://github.com/petercrlane/cmanship). Spezifisch:

* C89 Syntax (Vor allem Funktions-Signaturen)
* Änderungen in Headern und Library-Aufrufen zur Kompatibilität

AES hat sich ebenfalls in einigen Aspekten verändert, vor allem wenn
man MINT mit XaAES oder MyAES benutzt, mit neuen Messages und Möglichkeiten,
die auf einem Atari ST nicht vorhanden sind. Zum Beispiel ist es möglich,
Menüs innerhalb eines Fensters zu benutzen, und auch Toolbars ab oberen
Rand eines Fensters. Ich werde einige dieser Features in einem späteren
Abschnitt besprechen.

Nachdem ich CManShip durchgearbeitet hatte, versuchte ich ein paar
verschiedene Programme zu schreiben - teils mittels Trial-and-Error,
teils mit der Hilfe von Mitgliedern von http://atari-forum.com - und fühle
mich nun in der Lage, ein paar simple GEM-Programme zu erstellen. Dieses
Dokument ist zum Teil mein Versuch, aufzuzeichnen, was ich während dieses
Prozesses gelernt hatte. Ausserdem ist es auch ein Versuch, die von mir
genutzten Techniken zu vereinfachen und vereinheitlichen. Dieses Dokument
ist aber auch, in mehrerer Hinsicht, eine Dokumentation der Grenzen
meiner Kenntnisse, weshalb ich Sie bitte, alles Geschriebene
mit einer gesunden Portion Skepsis zur Kenntnis zu nehmen, und mir
allfällige Fehler und Verbesserungen mitzuteilen.

Ich setze voraus, dass Sie bereits Kenntnisse der Programmiersprace C
besitzen (genauer, C89), und auch wissen, was ein GEM Programm ist. Ich
werde versuchen aufzuzeigen, was es braucht, um in C ein funktionierende
GEM Programm zu schreiben welches mit dem Operating System interagiert.
Ich werde nicht viele Worte verlieren über die Erstellung einer RSC Datei -
Sie können dafür eine andere Dokumentation eigener Wahl beiziehen
(ich benutze ResourceMaster 3.65).

Diese Anleitung ist keine vollständige Referenz zur GEM Programmierung
mittels AES / VDI. Abgesehen von CManShip benutze ich folgende Referenzen
für die Liste von Konstanten und Funktions-Definitionen:

* "The Concise ATARI ST 68000 Programmer's Reference Guide" von Katherine Peel
* http://toshyp.atari.org (auch verfügbar als hyp-Datei Download).

Alternative Quellen:

* "Professional GEM" http://www.atari-wiki.com/index.php/Professional_GEM, von Tim Oren
* The Atari Compendium http://dev-docs.atariforge.org/files/The_Atari_Compendium.pdf

Diese Anleitung wurde geschrieben auf einer http://firebee.org[Firebee] mittels
QED. Zur Vorschau der Anleitung wurden http://peterlane.info/neso.html[Neso]
und NetSurf benutzt, und schliesslich wurde das PDF auf einem Ubuntu Computer
mittels asciidoc erzeugt. Die Beispiele wurden auf einer FireBee mit Version 5.3 des
http://members.chello.nl/h.robbers/[AHCC C Compilers] getestet, sowie wo
sinnvoll auf einem Hatari-emulierten Atari ST.

Quell-Code für die Anleitung und ihre Beispiel ist verfügbar unter:

https://github.com/petercrlane/gemguide

== AHCC Setup und Projekt-Dateien

AHCC kann heruntergeladen werden von http://members.chello.nl/h.robbers/

Es gibt keinen Installations-Schritt: Einfach entpacken und an einen
passenden Ort auf der Harddisk kopieren. Ich habe einen Desktop Shortcut
für das AHCC Programm, damit es jederzeit zugreifbar ist.

=== Probleme mit Version 5.3

Wir werden die include Libraries für AHCC benutzen (nicht die short-int
Variante in sinclude). Unglücklicherweise fehlen in Version 5.3 einige
der von uns benötigten Konstanten in "include/aes.h". Sie müssen diese
Konstanten kopieren von "sinclude/aes.h". Die fehlenden Konstanten sind:

----
#define WM_SHADED 22360		// <1>
#define WM_UNSHADED 22361
#define FL3DNONE 0x000		// <2>
#define FL3DIND 0x0200
#define FL3DBAK 0x0400
#define FL3DACT	0x0600
#define FL3DMASK 0x0600
#define SUBMENU 0x0800
----
<1> Diese beiden Events werden in TOS 4.0 Programmen verwendet.
<2> Diese Flags werden benötigt um Dialoge in einer Resource-Datei zu erzeugen.

Falls Sie "missing constant" Fehlermeldungen von AHCC erhalten, prüfen Sie zuerst
ob diese Konstanten tatsächlich in "include/aes.h" fehlen.

=== Projekt Dateien

Struktur einer Projekt-Datei:

----
; ein Kommentar
PROGRAM.PRG       ; <1>
.C [-7 -iinclude] ; <2>
=                 ; <3>
ahcstart.o        ; <4>

program.c         ; <5>

ahccstdi.lib      ; <6>
ahccgem.lib
gemf.lib
----
<1> Name des resultierenden compilierten Programmes.
<2> Optionale Liste von Parametern für die Compilierung.
<3> Trenner zwischen Output-Definition und Input-Dateien.
<4> Der Standard Startup-Code für den Linker.
<5> Liste der .c-Dateien Ihres Programmes.
<6> Normalerweise drei Libraries: Diese variieren, abhängig von der Ziel-Plattform.

Was üblicherweise in dem Projekt angepasst werden muss:

* Zeile (1) legt den Namen Ihres Programmes fest.
* Zeile (2) die Ziel-Plattform. -7 bedeutet Firebee / Coldfire, -2 für
  68020, und gar nichts für den Atari ST / 68000.
* Zeile (5) enthält alle C-Quelldateien Ihres Projektes.
* Zeile (6) diese und die folgenden Zeilen müssen für verschiedene Atari Plattformen
  angepasst werden; zum Beispiel müssen für die FireBee mit Fliesskomma-Support
  ahccstdf.lib und ahccgemf.lib angegeben werden. Die oben gezeigten Libraries
  passen zum Ausgabeziel Atari ST / 68000.

Die Standard-Library kommt in vier Versionen (Dank an Eero Tamminen
für seine Erklärungen hierzu):

. ahccstdf.lib (Firebee / Coldfire)
. ahccstd.lib (680x0 + FPU)
. ahccstdi.lib (68000 mit Fliesskomma-Support, der in printf/scanf fehlt)
. ahccstfi.lib (Firebee / Coldfire ohne FPU, könnte kompatibel sein mit Falcon)

=== Einstellungen

Wenn AHCC gestartet wird, benutzt es gemäss Voreinstellung die Libraries in
"sinclude". Diese verwenden einen "short int" Datentyp.

Bevor Sie die Programme hier ausprobieren, konfigurieren sie AHCC so dass es
die Libraries in "include" verwendet. Öffnen Sie dazu den "Config" Dialog
(Alt-O), suchen Sie "Options for the compiler" und setzen Sie die Checkbox
für die Zeile "-i include".

== Übersicht eines GEM Programmes

Wenn Sie vertraut sind mit GUI Programmierung auf modernen Computern, bitte
vergessen Sie alles, was Sie wissen. Programmierung in GEM ist primitiv. Mit
modernen Toolkits bekommt man alle Arten von Widgets, von Buttons über
Spinboxes bis hin zu kompletten Text-Editoren mit Support für Copy-/Paste
und scrollbaren Anzeige-Bereichen. Widgets können mit Layout Managern
in komplexen Arrangements kombiniert werden; Multi-Threading wird benutzt
um die Anzeige zu aktualisieren während das Programm mit der Berechnung
irgendeines Resultates beschäftigt ist.

Nichts davon ist in GEM verfügbar.

In GEM gibt es essentiell drei Elemente: Menüs, Dialog-Boxen (welche mehrere
"Widgets" enthalten können) und Fenster (Windows). Der Teil, der am meisten
Zeit beanspruchen wird, ist die Handhabung eines Fensters zu erlernen:
Ein Fenster ist ein Teil des Screens in welchem unsere Applikation freie
Hand hat. Sie haben totale Kontrolle über den Inhalt des Fensters. Sie
entscheiden was dort gezeichnet wird, wie das, was gezeichnet wird, reagiert
wenn der Benutzer den Schieber bewegt, und Sie müssen auch sicherstellen das
das, was Sie im Fenster zeichnen dort bleibt (und nur dort) während Ihr
Fenster interagiert mit den Fenstern anderer Applikationen (in MINT) oder
mit Desktop Accessories.

Die folgenden Sektionen werden schrittweise ein GEM Programm aufbauen um den
Umgang mit Fenstern zu illustrieren. Das Endresultat ist ein Programm welches
auf alle die erwarteten Fenster-Events reagiert, Scrollbars besitzt und
friedlich mit anderen Fenstern ko-existiert, während es seinen eigenen Inhalt
bewahrt, ohne seine Nachbarn zu stören. Jede Version des Beispiels steht mit
vollständigem Quellcode für diesen Guide zur Verfügung, und kann mit AHCC
compiliert werden.

Nachdem wir Fenster in den Griff bekommen haben gehen wir weiter zu einem
leichteren Aspekt der GEM-Programmierung: Menüs. Menüs sind definiert in der
RSC-Datei eines Programmes, und alles, was wir tun müssen ist, auf Messages
zu reagieren die anzeigen, dass ein Menüpunkt angewählt wurde. In diesem
Abschnitt werden wir auch anschauen wie man auf Tastatur-Befehle reagiert,
so dass Tastatur-Shortcuts benutzt werden können für Menü-Punkte.

Danach gehen wir weiter zu Dialog-Boxen. Das Hauptproblem mit Dialog-Boxen ist
sie anzuzeigen, und dann auf die Daten zuzugreifen die der Benutzer eingegeben
hat. Nur in Dialog-Boxen finden sich Widgets wie Buttons, Text-Felder und Labels
(ausser Sie benutzen ein spezielles, erweitertes AES welches Toolbars erlaubt,
was wir in einem späteren Abschnitt anschauen). Auch Dialog-Boxen werden
in der RSC-Datei des Programmes definiert.

HINWEIS: Obwohl der Umgang mit GEM viel Code erfordert, ist es mit etwas
Disziplin möglich, einen grossen Teil dieses Codes zwischen mehreren Projekten
wiederzuverwenden. Die Beispiele hier folgen meiner eigenen Praxis diesbezüglich.
Ich werde versuchen klarzumachen, welche Teile der Beispiele zwingend von
GEM vorausgesetzt werden, und welches meine eigenen Empfehlungen sind.

Die verschiedenen Komponenten eines GEM Fensters:

image::images/info.jpg[width=300]

Ein GEM Programm macht typischerweise das folgende:

. Die Applikation initialisieren
. Einen VDI-Screen öffnen und einen Handle dazu erlangen, um darauf zuzugreifen
. Optional eine RSC-Datei öffnen und ein Menü erzeugen
. Ein erstes Fenster oder mehrere Fenster öffnen
. Den Event-Loop starten und auf alle Fenster oder anderen Events antworten bis
  die Applikation beendet wird
. Alle Resourcen freigeben
. Den VDI-Screen freigeben
. Die Applikation beenden

== Beginn: Ein Fenster öffnen

In dieser ersten Sektion sehen wir, wie man ein GEM Programm startet und
das einfachste aller Fenster anzeigt. Dies entspricht dem "hello world"
der GEM Programmierung.

Ich finde es nützlich, den Code in drei separate Bereiche aufzuteilen:

. main.c enthält die +main+ Funktion und all den vorher erwähnten Setup-Code
  bevor das eigentliche Programm ausgeführt wird.
. windows.c enthält all den Standard GEM Code, sowie Funktionen um auf
  GEM Events zu reagieren.
. eg_draw.c enthält den spezifischen Code um den Inhalt des Fensters für diese
  Applikation zu zeichnen.

Die Header-Datei "windows.h" ist ebenfalls wichtig. Hier definieren wir einige
Variablen die AES benötigt, und auch unsere eigene Fenster Daten-Struktur (siehe unten).


=== Start einer GEM Applikation

Wir müssen unsere GEM Applikation starten und beenden mit einigem "startup"-
und "teardown"-Code. Dieser Code registriert unsere Applikation im Operating System
und stellt eine eindeutige Referenz zur Verfügung, um unsere Applikation zu identifizieren.

Ich platziere diesen Code im +main+, mit einem Aufruf einer Funktion um unsere
eigene Applikation zu starten (für ein vollständiges Listing, inklusive Header-Dateien
und Variablen-Definitionen, schauen Sie den begleitenden Quellcode zu diesem Guide an):

[source,c]
----
void main (int argc, char ** argv) {
	appl_init ();			// <1>
	open_vwork ();			// <2>
	start_program ();		// <3>
	rsrc_free ();			// <4>
	v_clsvwk (app_handle);		// <5>
	appl_exit ();			// <6>
}
----
<1> Dies ist eine AES-eigene Funktion die unsere Applikation initialisiert.
    Sie gibt eine eindeutige Referenz auf unsere Applikation zurück, die wir
    aber unmittelbar noch nicht brauchen. Diese Referenz wird nachfolgend
    "Handle" genannt.
<2> Diese Funktion müssen wir bereitstellen, und sie wird benutzt um einen
    "workspace" für unser Programm zu erstellen und zu öffnen, und den
    Applikations-Handle zu speichern.
<3> Diese Funktion stellen wird bereit, hier wird unser Programm ausgeführt.
<4> Nachdem unser Programm beendet wurde, werden Resourcen freigegeben.
<5> Mittels des Applikations-Handles von (2) wird der "workspace" geschlossen.
<6> Und schliesslich wird die Applikation beendet.

Funktionen (2) und (3) müssen wir selber bereitstellen. (2) ist ein Standard
Prozess um eine "workstation" zu öffnen, wie unten gezeigt. Ein wichtiger
Punkt hier ist die Erzeugung einer Referenz auf den Screen, durch den Aufruf
von +graf_handle+; diese Referenz wird gespeichert in der Variable +app_handle+.

[source,c]
----
void open_vwork (void) {
	int i;
	int dum;

	app_handle = graf_handle (&dum, &dum, &dum, &dum);	// <1>
	work_in[0] = 2 + Getrez ();				// <2>
	for (i = 1; i < 10; work_in[i++] = 1);	
	work_in[10] = 2;
	v_opnvwk (work_in, &app_handle, work_out);		// <3>
}
----
<1> Erzeugt den Ausgabe-Screen und speichert die Referenz. Wir benötigen
    die Werte der anderen Parameter nicht (welche sich auf die Grösse
    von Text im Screen beziehen).
<2> Erzeugen der Werte um eine virtuelle "workstation" zu deklarieren.
<3> Schliesslich erzeugen der virtuellen "workstation" für unsere Applikation.

=== Ein Fenster öffnen

Jedes Fenster in unserer Applikation wird dem Benutzer irgendwelche Informationen
anzeigen. Ein Fenster kann auf viele Events reagieren: Es kann auf dem Bildschirm
herum bewegt werden, vergrössert oder verkleinert werden oder seine Scrollbalken-Schieber
werden verschoben, und es muss die jederzeit seinen Inhalt aktuell halten. Es gibt
also mehrere Teilinformationen, die ein Fenster berücksichtigen muss. Aus diesem
Grunde benutze ich eine +struct+ um alle relevanten Daten zu einem einzelnen
Fenster zu speichern. Mein Basis +win_data+ sieht so aus:

[source,c]
----
struct win_data {
	int handle;	    /* handle des Fensters    <1> */
	char * text;	/* text der im Fenster angezeigt wird      <2> */
};
----
<1> Jedes Fenster hat einen eindeutigen +handle+ um es zu referenzieren.
<2> Applikations-spezifische Daten, zur Anzeige im Fenster.

Während wir durch diesen Guide voranschreiten, wird der Inhalt von +win_data+
erweitert werden. Zusätzlich wird Ihre Applikation diverse eigene Daten enthalten die
relevant sind fürs Fenster; diese sollten ebenfalls in +win_data+ gespeichert
werden: Für den Moment benutzen wir +text+ als unser Beispiel für
Applikations-spezifische Daten.

Ein Fenster zu erzeugen setzt voraus, dass eine Instanz von +win_data+ mit den
relevanten Daten erzeugt wird, und dann ein Fenster, welches dann angezeigt wird.
Der folgende Code erscheint in "windows.c", in der +start_program+ Funktion.

[source,c]
----
struct win_data wd;
int fullx, fully, fullw, fullh;

/* 1. set up and open our window *
wind_get (0, WF_WORKXYWH, &fullx, &fully, &fullw, &fullh);		// <1>
wd.handle = wind_create (NAME|CLOSER, fullx, fully, fullw, fullh);	// <2>
wind_set (wd.handle, WF_NAME, "Example: Version 1", 0, 0);		// <3>
wind_open (wd.handle, fullx, fully, 300, 200);				// <4>
wd.text = "Hello";							// <5>
----
<1> Diese Zeile ermittelt die aktuelle Desktop-Grösse. Der erste Parameter, 0,
    referenziert den Desktop. Der nächste, +WF_WORKXYWH+, legt fest welche Daten
    die Funktion ermitteln soll, und die verbleibenden Adressen sind die Bereiche
    in denen die Resultate gespeichert werden.
<2> Diese Zeile erzeugt das Fenster. Der erste Parameter definiert, welche
    Elemente das Fenster besitzen soll. Beachten Sie, dass wir den handle in
    unserer +wd+ Variable speichern. Des weiteren legen wir die maximale Grösse
    des Fensters fest - in diesem Fall die Grösse des Desktops.
<3> Setzt den Wert von +WF_NAME+ in unserem Fenster: Dies ist der Titel des
    Fensters (die Überschrift). Der Titel-Text muss in unserem Programm irgendwo
    gespeichert werden, da das AES keine Kopie davon macht.
<4> Zum Schluss wird das Fenster auf dem Screen geöffnet. Die letzten vier
    Parameter definieren die x- und y-Position, sowie mit w (width / Breite)
    und h (height / Höhe) die Grösse des Fensters. Diese Werte müssen nicht
    gleich sein wie die Maximal-Grösse.
<5> Dann werden noch die Applikations-spezifischen Daten für unser Fenster
    aufbereitet: In diesem Falle der Text, der im Fenster angezeigt werden soll.

TIP: Auf einem Atari ST, beispielsweise, ist es möglich, dass GEM irgendwann die
Fenster ausgehen und es keine neuen mehr öffnen kann. Wenn das passiert, ist der
von +wind_create+ zurückgegebene Handle negativ. Sie sollten deshalb zwischen
(2) und (3) prüfen ob +wd.handle+ negativ ist, und den Benutzer in diesem Falle
warnen. Wir ignorieren dies aber in unseren Beispiel-Programmen.

Die Funktionen +wind_set+ und +wind_get+ werden öfters zu sehen sein wenn Sie
mit Fenstern arbeiten. Beide verwenden einen Fenster-Handle als ihren ersten
Parameter, und dann einen Identifier für eine Komponente oder Daten dieses
Fensters. Handle 0 bedeutet dabei jeweils eine Referenz auf den Desktop.

Die Identifier beziehen sich auf verschiedene Elemente des Fensters. Ein paar
der Werte die wir benutzen werden sind:

* WF_NAME : Der Text im Titel des Fensters
* WF_INFO : Der Text in der Informations-Zeile des Fensters
* WF_WORKXYWH : Der aktuelle Arbeitsbereich des Fensters, in welchem gezeichnet wird
* WF_CURRXYWH : Die aktuelle Fenstergrösse, einschliesslich seiner Widgets
* WF_PREVXYWH : Die vorherige Fenstergrösse, einschliesslich seiner Widgets
* WF_FULLXYWH : Die maximale  Fenstergrösse, einschliesslich seiner Widgets
* WF_HSLIDE : Die Position des horizontal Scrollbar-Schiebers
* WF_VSLIDE : Die Position des vertikalen Scrollbar-Schiebers
* WF_HSLSIZE : Die Grösse des horizontalen Schiebers
* WF_VSLSIZE : Die Grösse des vertikalen Schiebers

Beachten Sie, dass wir in +wind_create+ die Flags +NAME|CLOSER+ benutzt haben. Diese
instruieren unser Fenster, Platz für einen Titel und für eine Schliess-Box bereitzustellen.
Wir setzen dann den Titel durch +WF_NAME+, wie oben. Die Schliess-Box wird benutzt um
das Programm zu beenden, und wir werden genauer betrachten wie dies funktioniert wenn
wir den Event-Loop behandeln. Fenster können viele Elemente beinhalten, und um diese zu
nutzen müssen sie in der Liste von Flags aufgeführt werden. Einige übliche Flags sind:

* NAME : Für den Titel des Fensters
* CLOSER : Addiert eine Schliess-Box
* FULLER : Addiert ein Element um das Fenster zu maximieren und wiederherzustellen
* MOVER : Erlaubt es, das Fenster zu verschieben
* INFO : Eine interne Informations-Zeile für das Fenster
* SIZER : Erlaubt es, die Fenstergrösse zu ändern (re-sizing)
* UPARROW : Zeigt den Aufwärts-Pfeil der vertikalen Scrollbar
* DNARROW : Zeigt den Abwärts-Pfeil der vertikalen Scrollbar
* VSLIDE : Zeigt eine vertikale Scrollbar
* LFARROW : Zeigt den Links-Pfeil der horizontalen Scrollbar
* RTARROW : Zeigt den Rechts-Pfeil der horizontalen Scrollbar
* HSLIDE : Zeigt eine horizontale Scrollbar

Die Funktion +start_program+ geht weiter wie folgt:

[source,c]
----
draw_example (app_handle, &wd);			// <1>

/* 2. process events for our window */
event_loop (&wd);				// <2>

/* 3. close and remove our window */
wind_close (wd.handle);				// <3>
wind_delete (wd.handle);			// <4>
----
<1> Zeichnet den Inhalt unseres Fensters (nur für Version 1).
<2> Wartet darauf, dass der Benutzer mit unserem Programm interagiert.
    Endet, wenn der Benutzer das Fenster schliesst.
<3> Um aufzuräumen schliessen wir zuerst das Fenster und entfernen es dann vom Screen.
<4> Zum Schluss löschen wir das Fenster und geben seinen Handle frei zur Wiederbenutzung.
    
=== Inhalt anzeigen

Eine Funktion +draw_example+ zeichnet den Fenster-Inhalt auf den Screen. Unser
Beispiel zeigt schlicht den gegebenen Text im Fenster.

[source,c]
----
void draw_example (int app_handle, struct win_data * wd) {

	v_gtext (app_handle, 10, 60, wd->text); // <1>

}
----
<1> Zeit Text an der gegebenen Koordinate auf dem Screen an. Wichtig:
    Wir benutzen +app_handle+, welches den Screen referenziert, wenn
    wir VDI Funktionen aufrufen.

=== Event Loop

Alle GEM Programme arbeiten "Event"-getrieben. Das bedeutet dass das Programm
darauf wartet, dass der Benutzer oder das Betriebssystem ihm einen Event schicken,
um etwas zu tun. Das Programm führt dann die gewünschte Aktion für den Event
aus, bevor es in den Loop (Schleife) zurückkehrt. Beispiel: Anklicken der
Schliess-Box links oben im Rahmen des Fensters sendet eine Nachricht (Message)
an unser Programm. Das Programm muss dann darauf entsprechend reagieren; in
diesem Falle müssen wir das Fenster schliessen und das Programm beenden.

Für das Beispiel werden wir Events mittels der Funktion +evnt_mesag+ in unserem
Programm verarbeiten. In einem "richtigen" GEM Programm werden Sie den grossen
Bruder +evnt_multi+ benutzen, welches erlaubt, Events von der Maus, der Tastatur
oder anderen Quellen zu verarbeiten, sowie solche für das Fenster. Für das Beispiel
werden wir der Einfachheit halber nur auf Fenster-Events reagieren, deshalb
benutzen wir diesen Aufruf.

[source,c]
----
void event_loop (struct win_data * wd) {
	int msg_buf[8];				// <1>

	do {
		evnt_mesag (msg_buf);		// <2>

	} while (msg_buf[0] != WM_CLOSED);	// <3>
}
----
<1> Erzeugt Speicherplatz fuer die Event-Message.
<2> Verarbeitet den nächsten Event.
<3> Bleibt in dem Loop bis eine +WM_CLOSED+ Nachricht verarbeitet
    wird, die anzeigt dass der Benutzer die Schliessbox angeklickt hat.

In späteren Abschnitten werden wir in dem Loop auf mehr Arten von Events
reagieren. Wir werden dann andere mögliche Werte für +msg_buf+ besprechen.

=== Beispiel Programm: Version 1

An diesem Punkt haben wir ein Fenster welches etwas Text anzeigt. Wenn Sie
aber ein anderes Fenster darüber ziehen, wird der Inhalt verschwinden.
Ausserdem ist keines der Fenster-Widgets ausser der Schliessbox funktional;
wir können das Fenster nicht verschieben, es nicht durch anklicken in den
Vordergrund holen usw. Ausserdem ist der Hintergrund durch das Fenster
hindurch sichtbar, was vor allem in einer Multitasking-Umgebung wie
MINT ein Problem ist.

== Ein Fenster aktualisieren: Redraw Events

Wir möchten gern eine schöne Anzeige in unserem Fenster. Zuerst einmal
soll der Hintergrund nicht zu sehen sein, sondern statt dessen eine hübsche,
saubere Fläche. Zweitens soll das Fenster konstant den Inhalt anzeigen den
wir wollen, selbst wenn wir ein anderes Fenster darüber ziehen und wieder
weg bewegen.

Obgleich nachfolgend mehrere Schritte ausgeführt werden, ist der Code
vollständig wiederverwendbar in all Ihren GEM-Programmen. Wenn Sie mal
eine funktionierende Vorlage haben, können Sie diese einfach kopieren,
und alles sollte funktionieren.

=== In einem Bereich zeichnen

Schauen Sie wiederum unsere Funktion +draw_example+ an: Der Aufruf von
+v_gtext+ referenziert nicht unser Fenster, sondern nur den Screen. Unser
Zeichnungs-Code könnte theoretisch überall auf dem Screen direkt etwas
zeichnen. Doch dies würde natürlich die Illusion zerstören, ein Fenster
zu haben, welches einen Blick auf bestimmte Informationen freigibt.
Eine bessere Lösung ist es, einen _Clipping_ Bereich festzulegen:
Dies ist ein Rechteck welches wir definieren, so dass jegliche VDI
Aufrufe ausserhalb dieses Bereiches automatisch abgeschnitten werden,
und nur auf den entsprechenden Bereich beschränkt zu sehen sind.

Demzufolge packen wir unseren Aufruf von +draw_example+ in eine Funktion +draw_interior+,
welche den Clipping-Bereich definiert und auch die Anzeige unseres Fensters für uns
löscht. Die folgende +draw_interior+ Funktion erledigt eine Menge nützlicher
Dinge für uns. Zuerst versteckt sie die Maus, damit wir nicht darüber zeichnen.
Zweitens definiert sie den Clipping-Bereich (+set_clip+ ist definiert in "windows.c"),
so dass alle unsere VDI-Aufrufe nur innerhalb des gegebenen Rechtecks wirksam sind.
Dann ermitteln wir die Grösse des Arbeitsbereiches unseres Fensters. Dies ist der
gleiche +wind_get+ Aufruf den wir zuvor gemacht haben, nur dass wir jetzt für
den Arbeitsbereich unseres Fensters statt des Desktops nachfragen. Der
Arbeitsbereich schliesst die Fenster-Elemente wie Scrollbars etc. nicht mit ein.
Ein Aufruf um das Fenster zu leeren, und wir können dann den Code aufrufen, der
den gewünschten Inhalt zeichnet. Schliesslich wird das Clipping wieder deaktiviert
und die Maus wieder angezeigt.

[source,c]
----
/* Zeichnet Fenster-Inhalt innerhalb des Clipping-Bereichs */
void draw_interior (struct win_data * wd, GRECT clip) {
	int pxy[4];
	int wrkx, wrky, wrkw, wrkh; /* ein paar Variablen die den aktuellen Arbeitsbereich beschreiben */

	/* bereitet das zeichnen vor, indem der Mauszeiger versteckt und Clipping aktiviert wird */
	graf_mouse (M_OFF, 0L);					// <1>
	set_clip (true, clip);
	wind_get (wd->handle, WF_WORKXYWH, &wrkx, &wrky, &wrkw, &wrkh);

	/* loescht das display */
	vsf_color (app_handle, WHITE);				// <2>
	pxy[0] = wrkx;
	pxy[1] = wrky;
	pxy[2] = wrkx + wrkw - 1;
	pxy[3] = wrky + wrkh - 1;
	vr_recfl (app_handle, pxy);

	/* unser spezifischer Code um den Inhalt zu zeichnen */
	draw_example (app_handle, wd);				// <3>

	/* aufraeumen */
	set_clip (false, clip);					// <4>
	graf_mouse (M_ON, 0L);
}
----
<1> Versteckt die Maus, aktiviert das Clipping und ermittelt den Arbeitsbereich.
<2> Löscht den Arbeitsbereich.
<3> Aufruf unseres Zeichnungs-Codes.
<4> Deaktiviert das Clipping wieder und macht den Mauszeiger wieder sichtbar.

=== Display aktualisieren

Einer der komplexeren Aspekte des Umgangs mit Fenstern in GEM ist das Konzept
der Rechteck-Listen, und wie man sie managed. Die Grundidee ist sehr einfach.
Nehmen wir an, das Fenster unseres Programmes ist verdeckt von diversen
anderen Fenstern. Eines dieser Fenster wird geschlossen. Unser Fenster
erhält eine Message um den Teilbereich neu zu zeichnen, der sich unter
dem anderen Fenster befand, welches nun geschlossen wurde.

Wir können aber nun nicht einfach diesen Bereich blind mit dem Inhalt
unseres Fensters füllen, da noch andere Fenster ebenfalls diesen Bereich
teilweise verdecken könnten. Deshalb müssen wir sämtliche Fenster im
System anschauen und prüfen, welche unser Fenster verdecken, und
sicherstellen, dass wir nicht in diese Fenster hinein zeichnen.

Schauen Sie als Beispiel die folgenden zwei Bilder an. Im ersten Bild
haben wir drei Fenster, die sich alle gegenseitig überlappen. Nun schliessen
wir das oberste Fenster: Wie soll das hintere Fenster (das welches die Liste
"Classic 1" anzeigt) aktualisiert werden?

image::images/redraw-1.png[width=300]

Das zweite Bild zeigt die Szene mit dem obersten Fenster geschlossen. Das
hervorgehobene Rechteck zeigt den Bereich, der aktualisiert werden muss -
und nur diesen Bereich. Wenn wir irgendeinen anderen Bereich des unteren
Fensters neuzeichnen, werden wir Inhalte des darüberliegenden Fensters
überschreiben.

image::images/redraw-2.png[width=300]

Der Prozess um sicherzustellen, dass nur der benötigte Bereich aktualisiert
wird, nennt sich "Rechteck-Liste durchgehen". Unsere Applikation enthält
den gesamten Bereich der freigelegt wurde durch das Schliessen des oberen
Fensters, und der aktualisiert werden muss. Unsere Applikation vergleicht
diesen Bereich mit den anderen Fenstern, die darüber liegen, bevor es das
hervorgehobene Rechteck ermittelt für die Zeichenoperation.

Die Rechteck-Liste durchgehen geschieht mittels zweier Operationen:

. +wind_get (wd->handle, WF_FIRSTXYWH, ...)+ ermittelt das erste Rechteck
  relevant für unser Fenster, wobei dessen x, y, w, h Werte in den
  verbleibenden Referenz-Parametern gespeichert werden.
. +wind_get (wd->handle, WF_NEXTXYWH, ...)+ ermittelt das nächste Rechteck,
  wobei wiederum dessen x, y, w, h Werte in den verbleibenden
  Referenz-Parametern gespeichert werden.

Dies geht so weiter solange die erhaltenen w (width / Breite) und h (height / Höhe)
Werte nicht Null sind: Wenn beide Null (0) sind haben wir das Ende der
Rechtecks-Liste erreicht.

Alles was wir prüfen ist, ob die Rechtecke in der Liste unser Rechteck zur
Aktualisierung überlappen, und falls ja, zeichnen wir den überlappenden Bereich neu.

[source,c]
----
/* Aufgerufen wenn die Applikation aufgefordert wird, Teile ihres
   Displays neu zu zeichnen. Arbeitet die Rechteck-Liste durch und
   zeichnet jeden relevanten Fensterteil erneut.
 */
void do_redraw (struct win_data * wd, GRECT * rec1) {
	GRECT rec2;

	wind_update (BEG_UPDATE);			// <1>

	wind_get (wd->handle, WF_FIRSTXYWH, 
		  &rec2.g_x, &rec2.g_y, &rec2.g_w, &rec2.g_h); // <2>
	while (rec2.g_w && rec2.g_h) {			// <3>
		if (rc_intersect (rec1, &rec2)) {	// <4>
			draw_interior (wd, rec2);	// <5>
		}
		wind_get (wd->handle, WF_NEXTXYWH, 
			  &rec2.g_x, &rec2.g_y, &rec2.g_w, &rec2.g_h); // <6>
	}

	wind_update (END_UPDATE);			// <7>
}
----
<1> Deaktiviert alle anderen Fenster-Updates während wir den Inhalt unseres Fensters aktualisieren
<2> Ermittelt das erste zu aktualisierende Rechteck
<3> Nun loopen wir in der Schleife solange es ein Rechteck gibt, das noch aktualisiert werden muss.
<4> Prüfe of das zu aktualisierende Rechteck den Teil des Displays überlappt, den wir neu zeichnen müssen.
<5> Zeichne unseren Fensterinhalt nur in dem Bereich, in dem sich die beiden Rechtecke überlappen.
<6> Ermittle das nächste zu aktualisierende Rechteck.
<7> Schalte die Aktualisierung der anderen Fenster wieder ein.

(Beachten Sie dass +rc_intersect+ von der AHCC library zur Verfügung gestellt wird.)

=== Auf REDRAW Events reagieren

Was macht das AES wenn es denkt dass unser Fenster aktualisiert werden muss?
Es sendet uns einen REDRAW Event. Zusammen mit dem Event teilt es uns den Handle
des zu aktualisierenden Fensters mit, sowie ein Rechteck: Dieses Rechteck definiert
den Bereich unseres Fensters der aktualisiert werden soll.

Für einen REDRAW Event erhalten wir die folgenden Informationen in +msg_buf+:

* msg_buf[0] = WM_REDRAW, der Typ des Events.
* msg_buf[3] = Handle des Fensters, welches aktualisiert werden soll.
* msg_buf[4] = x-Koordinate des zu aktualisierenden Bereichs.
* msg_buf[5] = y-Koordinate des zu aktualisierenden Bereichs.
* msg_buf[6] = Breite des zu aktualisierenden Bereichs, in Pixeln.
* msg_buf[7] = Höhe des zu aktualisierenden Bereichs, in Pixeln.

[source,c]
----
do {
	evnt_mesag (msg_buf);

	switch (msg_buf[0]) {                                 	// <1>
		case WM_REDRAW:   				// <2>
			do_redraw (wd, (GRECT *)&msg_buf[4]);	// <3>
			break;
	}
} while (msg_buf[0] != WM_CLOSED);
----
<1> Wir benutzen ein "switch"-Statement um die Aktion auszuwählen, auf
    die wir reagieren, abhängig vom Event-Typ.
<2> Der Typ für einen REDRAW-Event.
<3> Wir rufen einfach unsere +do_redraw+ Funktion auf. Da wir in diesem
    Programm nur ein Fenster haben, können wir die Daten dafür direkt
    übergeben. Beachten Sie wie die x, y, w, h Koordinaten in msg_buf[4,5,6,7]
    in den GRECT-Typen übertragen werden.

Dieser Teil des Programms erledigt eine Menge harter Arbeit. Zur Wiederholung:
Unser Programm muss Teile seines Displays neu zeichnen; es wird einen REDRAW
Event erhalten, welcher einen Fenster-Handle enthält sowie den zu aktualisierenden
Bereich. Wir reichen diese Daten an die +do_redraw+ Funktion, welche die
Rechtecks-Liste durcharbeitet und sicherstellt, dass wir nur diese Teile des
Fensters neu zeichnen, welche nicht von einem anderen Fenster verdeckt werden.
+do_redraw+ ruft sodann für jedes nicht verdeckte Rechteck +draw_interior+
welche den Clipping-Bereich für das nicht verdeckte Rechteck setzt, und
zeichnet unsere Applikations-Daten in diesen Bereich.

Die gute Nachricht hier ist zweiteilig. Erstens, nachdem wir nun all diesen
Code geschrieben haben, werden wir das mehr oder weniger genauso machen
für jedes andere GEM Programm. Der Hauptteil, den Sie in einem neuen
Programm anpassen müssen ist +draw_example+, bzw. das äquivalent dazu.
Zweitens wird dieser Ablauf jedesmal dann ausgeführt, wenn der Computer
denkt dass der Screen aktualisiert werden muss, weshalb Sie selber sonst
nichts weiter machen müssen um das Fenster aktuell zu behalten. Insbesondere
wird unser Programm beim starten schon einen REDRAW Event erhalten, was zur
Folge hat, dass wir den Aufruf von +draw_example+ in +start_program+
entfernen können.

=== Beispiel-Programm: Version 2

Diese Version beinhaltet die REDRAW Events, das Durcharbeiten der Rechtecks-Liste
und den Code zum löschen des Display-Hintergrundes. Wenn Sie den Code ausführen
müsste das Display nun wesentlich besser aussehen. Versuchen Sie, ein anderes
Fenster über das unseres Programmes zu ziehen: Beachten Sie, wie das Display
sich selber aktualisiert und damit unser Fenster immer so anzeigt wie gewünscht.

Doch nun ist es Zeit, mal einige der anderen möglichen Fenster-Elemente zu
benutzen, und die von ihnen ausgehenden Events zu verarbeiten.


== Einfache Fenster Events: TOP und MOVE

Die ersten beiden Events die wir behandeln sind sehr simpel, da wir uns darauf
verlassen können, dass das AES die notwendigen Schritte ausführt. Diese beiden
Events werden getriggert wenn unser Fenster in den Vordergrund des Screens
gebracht wird, oder wenn unser Fenster an eine andere Position verschoben wird.

=== TOP

Wenn mehrere Fenster offen sind, ist nur eines "on top", also zuoberst, bzw.
im Vordergrund. Sie können ein Fenster in den Vordergrund bringen indem Sie
es anklicken, oder indem Sie ein anderes, darüber liegendes Fenster schliessen.

Wenn unser Fenster in den Vordergrund gebracht wird, erhält unsere Applikation
die Event-Message +WM_TOPPED+. Der Handle unseres Fensters wird in +msg_buf+
mitgeteilt. Alles, was wir tun müssen, ist unser Fenster mittels +wind_set+
in den Vordergrund zu bringen.

In unserem Event-Loop fügen wir den folgenden Code hinzu:

[source,c]
----
case WM_TOPPED:
	wind_set (msg_buf[3], WF_TOP, 0, 0);
	break;
----

Sie fragen sich vielleicht wie ein Fenster, das teilweise von einem anderen Fenster
verdeckt worden war, neu gezeichnet wird, wenn es in den Vordergrund gebracht wird.
Die Antwort ist dass ich ein bisschen gelogen hatte als ich sagte, dass alles was
wir zu tun hätten das oben beschriebene sei: AES wird einen REDRAW-Event für ein
Fenster auslösen, wenn es in den Vordergrund gebracht wird, weshalb unser Programm
den Fenster-Inhalt neu zeichnet. Und da wir REDRAW-Events bereits verarbeiten
haben wir nichts weiter zu tun - unser vorheriger Code und AES erledigen bereits alles
notwendige für uns.

=== MOVE

Fenster können verschoben werden, üblicherweise indem man den oberen Rahmen anklickt
und dann zieht. Damit dies funktioniert müssen Sie die MOVER Option in die Element-Liste
für Ihr Fenster hinzufügen, wenn Sie es erzeugen (siehe der Abschnitt zur Erzeugung
von Fenstern).

Wenn Ihr Fenster verschoben wird ist alles, was Sie tun müssen, die Koordinaten des
Fensters auf die Werte der neuen Position zu aktualisieren. Die neue Position wird
mitgeteilt in +msg_buf+, Bytes 4-7.

In unserem Event-Loop fügen wir folgenden Code hinzu:

[source,c]
----
case WM_MOVED:
	wind_set (msg_buf[3], WF_CURRXYWH, msg_buf[4],
		msg_buf[5], msg_buf[6], msg_buf[7]);
	break;
----

AES kopiert den Inhalt unseres Fensters direkt an seine neue Position (AES schickt
auch REDRAW-Messages an jedes Fenster, welches von unserem verdeckt worden war -
was uns aber nicht weiter betrifft).

Wir müssen nun aber einen genaueren Blick auf unseren Zeichnungs-Code werfen, nun
da unser Fenster überallhin auf dem Screen verschoben werden kann. Erinnern Sie
sich daran, dass der Code, der auf den Screen zeichnet, dies mittels des VDI
erledigt, und dass wir keine Referenz auf unser Fenster dafür bereitstellen.
Wenn wir unser Fenster bewegen, müssen wir den Inhalt an einer neuen Position
wieder zeichnen. Um das zu tun übergeben wir die Koordinaten der Ziel-Position
an unsere Zeichen-Funktion. Die angegebenen x,y Koordinaten repräsentieren den
Ursprungs-Punkt für unsere Zeichnungs-Operationen. Wir übergeben diese Koordinaten
von +draw_interior+ an unseren Zeichnungs-Code.

[source,c]
----
void draw_example (int app_handle, struct win_data * wd, int x, int y, int w, int h) {

	v_gtext (app_handle, x+10, y+60, wd->text); // <1>

}
----
<1> Wir verschieben die Position fürs Zeichnen um die x,y Koordinaten des Fensters.

=== Beispiel Programm: Version 3

Version 3

Version 3 beinhaltet jetzt diese beiden Events. Beachten Sie auch die Nutzung
von +MOVER+ wenn das Fenster erzeugt wird, und die aktualisierten +draw_example+
und +draw_interior+ Funktionen.

Unser Fenster ist jetzt ein respektables GEM Programm. Es aktualisiert sich
selbst wenn nötig, stört keine anderen Fenster im System, kann auf dem Screen
herum bewegt und in den Vordergrund gebracht werden. Wenn Ihnen ein Fenster
mit fixer Grösse reicht, haben Sie jetzt genug zusammen um eine GEM
Applikation zu implementieren.


== Fenster-Grösse ändern: FULL und RESIZE

Die nächsten beiden Fenster-Elemente die wir anschauen werden benutzt, um die
Grösse des Fensters zu ändern. Das erste, FULLER (Maximier-Box), erlaubt es,
das Fenster auf seine maximale Grösse zu erweitern. Klickt man ein zweites
Mal auf die Maximier-Box schrumpft das Fenster wieder auf seine vorherige
Grösse zurück. Das zweite Element ist der SIZER, die Box rechts unten die
es ermöglicht, das Fenster dynamisch auf jede gewünschte Grösse zu ändern.

Beide diese Elemente benötigen die +wind_set+ Funktion um die aktuellen
x, y, w, h Dimensionen des Fensters festzulegen.

=== FULLER

Das FULL Widget wird benutzt um das Fenster auf die maximale Grösse zu öffnen.
Diese maximale Grösse wurde festgelegt beim erzeugen des Fensters; normalerweise
handelt es sich dabei um die Grösse des Desktops: Diese Werte haben wir in den
+fullx+ etc. Feldern unserer Fester-Daten gespeichert. Einmal maximiert kann
das Fenster wieder auf die vorherige Grösse gebracht werden, indem nochmal das
FULL Widget angeklickt wird. Das AES ermöglicht es, die vorherigen Dimensionen
des Fensters in einem Aufruf von +wind_get+ zu ermitteln mittels +WF_PREVXYWH+.

Glücklicherweise stellt das AES auf zwei Arten sicher, dass das Display immer
aktuell gehalten wird. Erstens, wenn das Fenster kleiner gemacht wird, muss
nichts aktualisiert werden, da nur Inhalte abgeschnitten werden. Zweitens,
wenn das Fenster maximiert wird, wird es grösser, weshalb ein REDRAW Event
an unsere Applikation geschickt wird, um die neuen Rechtecke zu zeichnen.
Da wir diese Events bereits verarbeiten, braucht es keine besonderen Massnahmen.

Die Funktion um den FULL-Event zu behandeln sieht wie folgt aus. Sie ist
aufgeteilt in zwei Teile: Wenn das Fenster schon auf maximaler Grösse ist,
müssen wir seine vorherige Grösse ermitteln und die Dimensionen des Fensters
auf diese Werte setzen. Wenn das Fenster noch nicht seine maximale Grösse
hat, müssen wir diese ermitteln und dann das Fenster auf diese Grösse setzen.
Zusätzlich ist es üblich, eine kleine Animation zu zeigen für das Vergrössern
oder Verkleinern des Fensters, deshalb der Aufruf von +graf_shrinkbox+. Auf
sehr schnellen Computern ist das eventuell gar nicht zu sehen; auf der FireBee
etwa kann ich die Animationen nicht sehen.

[source,c]
----
void do_fulled (struct win_data * wd) {
	if (is_full_window (wd)) { /* das Fenster ist schon maximiert, also zurück-schrumpfen */
		int oldx, oldy, oldw, oldh;
		int fullx, fully, fullw, fullh;

		wind_get (wd->handle, WF_PREVXYWH, &oldx, &oldy, &oldw, &oldh);	     // <1>
		wind_get (wd->handle, WF_FULLXYWH, &fullx, &fully, &fullw, &fullh);  // <2>
		graf_shrinkbox (oldx, oldy, oldw, oldh, fullx, fully, fullw, fullh); // <3>
		wind_set (wd->handle, WF_CURRXYWH, oldx, oldy, oldw, oldh);          // <4>

	} else { /* Fenster maximieren */
		int curx, cury, curw, curh;
		int fullx, fully, fullw, fullh;

		wind_get (wd->handle, WF_CURRXYWH, &curx, &cury, &curw, &curh);
		wind_get (wd->handle, WF_FULLXYWH, &fullx, &fully, &fullw, &fullh); // <2>
		graf_growbox (curx, cury, curw, curh, fullx, fully, fullw, fullh);
		wind_set (wd->handle, WF_CURRXYWH, fullx, fully, fullw, fullh);
	}
}
----
<1> Ermittelt die vorherigen Dimensionen des Fensters.
<2> Ermittelt die maximalen Dimensionen des Fensters.
<3> Zeichnet eine kleine Animation beim Schrumpfen des Fensters.
<4> Setzt die Fenster-Grösse auf die vorherigen Dimensionen.

Beachten Sie die Funktion +is_full_window+, welche +true+ zurückgibt, wenn
das Fenster tatsächlich bereits seine maximale Grösse hat. Diese Funktion
vergleicht schlicht die aktuelle mit der maximalen Grösse des Fensters.
Die Funktion sieht so aus:

[source,c]
----
bool is_full_window (struct win_data * wd) {
	int curx, cury, curw, curh;
	int fullx, fully, fullw, fullh;

	wind_get (wd->handle, WF_CURRXYWH, &curx, &cury, &curw, &curh);
	wind_get (wd->handle, WF_FULLXYWH, &fullx, &fully, &fullw, &fullh);
	if (curx != fullx || cury != fully || curw != fullw || curh != fullh) {
		return false;
	} else {
		return true;
	}
}
----

Und zu guter Letzt muss auf +WM_FULLED+ Events reagiert werden im Event-Loop,
und zwar wie folgt:

----
case WM_FULLED:
	do_fulled (wd);
	break;
----

=== SIZER

Das SIZER-Element erlaubt es dem Benutzer, die Grösse des Fensters interaktiv
auf jede gewünschte Grösse zu ändern (rechte untere Fenster-Ecke). Das AES
teilt Ihrer Applikation mit, wenn der SIZER benutzt wurde, und damit dann
auch die neue Grösse des Fensters (in +msg_buf+). Ihr Programm muss dann
die Grösse des Fensters ändern, und allfällige andere Änderungen vornehmen
die nötig sein können, damit der Inhalt für die neue Fenstergrösse korrekt
angepasst wird (das ist vor allem wichtig wenn das Fenster Scrollbalken-Schieber
benutzt, was wir im nächsten Abschnitt anschauen).

Glücklicherweise stellt das AES sicher dass das Display aktuell gehalten wird,
genauso wie mit dem vorher besprochenen FULLED-Event.

Der benötigte Code um die Grösse des Fensters effektiv zu ändern ist jetzt
relativ einfach. Alles, was es braucht ist die Dimension des Fensters auf
die neue Grösse zu setzen. Zusätzlich implementieren wir einen einfachen
Test um sicherzustellen, dass die neue Grösse nicht _zu_ klein ist, so dass
der Benutzer das Fenster nur bis zu einem gewissen Minimum verkleinern kann.

[source,c]
----
void do_sized (struct win_data * wd, int * msg_buf) {
	if (msg_buf[6] < MIN_WIDTH) msg_buf[6] = MIN_WIDTH;	// <1>
	if (msg_buf[7] < MIN_HEIGHT) msg_buf[7] = MIN_HEIGHT;

	wind_set (wd->handle, WF_CURRXYWH, 
		  msg_buf[4], msg_buf[5], msg_buf[6], msg_buf[7]); // <2>
}
----
<1> Um zu verhindern dass der Benutzer unser Fenster bis zur Unsichtbarkeit
    verkleinert, prüfen wir, dass die neue Breite und Grösse nicht zu klein sind.
    Die minimalen Dimensionen sind definiert in "windows.h".
<2> Alles was wir tun müssen, ist die Dimensionen unseres Fensters auf die
    neue Grösse zu ändern.

Um auf SIZE-Events zu reagieren, muss der Event-Loop noch um die Behandlung
dieser Events erweitert werden:

[source,c]
----
case WM_SIZED:
	do_sized (wd, msg_buf); // <1>
	break;
----
<1> Übergibt das Fenster und den Message-Buffer an +do_sized+.

=== Beispiel Programm: Version 4

Version 4 nun mehr Fenster-Elemente: Sie können das Fenster vergrössern oder
verkleinern mit dem Button rechts unten, und Sie können das Fenster auch
zwischen seiner Maximal- und seiner aktuellen Grösse hin- und herschalten.

Um die Anzeige interessanter zu gestalten enthält das Fenster mehrere Zeilen
eines Gedichtes. Sie müssen das Fenster vergrössern, um mehr vom Gedicht zu
sehen. Wieviel Sie sehen können hängt von der Grösse Ihres Screens ab. Um
den Rest des Gedichtes zu sehen, müssen wir nun irgendwie das Fenster "über"
das Gedicht legen; das führt uns zum nächsten Thema, "Schieber" ("slider").


== Fenster-Inhalte verschieben

Die Scrollbalken-Schieber ("Sliders") erzeugen die Illusion, dass das Fenster
einen Blick auf eine grössere Fläche gewährt. Schieber sind kompliziert zu
handhaben, da Benutzer verschiedene Möglichkeiten haben, um damit zu interagieren.
Ein Schieber kann direkt gezogen werden, Benutzer können die Pfeile anklicken,
oder den Scrollbalken selber. Da es zwei Schieber gibt, bedeutet das für uns
zehn Funktionen, nur um die Schieber zu handhaben. Dazu kommt, dass eine
Änderung der Grösse oder des Inhaltes des Fensters dazu führt, dass sich
auch die Positionen und die Grössen der Schieber verändern, und entsprechend
angepasst werden müssen.

Ich werde den Code für die Schieber und Pfeile in einem Durchgang behandeln,
da dies alles zusammenhängt. Ausserdem sind die horizontalen und vertikalen
Schieber essentiell dasselbe, was den Code angeht, weshalb ich hauptsächlich
den Code für den vertikalen Schieber aufzeige: Code für den horizontalen
Schieber ist ähnlich, und im Beispiel-Code enthalten.

Wegen der grossen Zahl von Events die behandelt werden müssen (total 10)
wird dies der umfangreichste Teil unseres Programmes, und der komplizierteste.
Hinzugefügte Schieber müssen auch bedacht werden, wenn der Inhalt des
Screens gezeichnet wird.

Fangen wir damit an, dass wir Schieber zu unserem Programm hinzufügen und
dafür sorgen, dass die Schieber die korrekte Grösse und Position bekommen.
Dann modifizieren wir +draw_example+ um alles korrekt anzuzeigen, bevor
wir schliesslich sehen, wie auf alle Events reagiert werden muss.

=== Die Schieber anzeigen

Die Schieber und Pfeile hinzuzufügen geschieht über die Element-Liste beim
erzeugen des Fensters. Wir müssen den Schieber mit seinen beiden Pfeilen
hinzufügen. Eine vollständige Element-Liste mit all den erwähnten Widgets
sieht dann so aus:

----
NAME|CLOSER|FULLER|MOVER|SIZER|UPARROW|DNARROW|VSLIDE|LFARROW|RTARROW|HSLIDE
----

Das AES macht etwas Platz frei für die Schieber, so wie auch für die anderen
Fenster-Elemente, und überlässt uns den verbleibenden Platz um unseren Inhalt
zu zeichnen. Aus diesem Grund benutzen wir für die Behandlung von Operationen
wie Maximierung +WF_CURRXYWH+ um die aktuellen Fenster-Dimensionen zu ermitteln;
wenn wir hingegen _im_ Fenster zeichnen wollen rufen wir +WF_WORKXYWH+ auf, um
den aktuellen Arbeitsbereich zu ermitteln.

Mit anderen Worten, der "Arbeitsbereich" ist der innere Teil des Fensters, in
dem wir unsere Applikations-Daten anzeigen, also das Fenster ohne die Rahmen.

=== Schieber setzen

Jeder Schieber hat zwei Parameter: Seine _Grösse_ (size) und seine _Position_.
Die Grösse muss proportional dem momentan sichtbaren Teil des Fenster-Inhaltes
entsprechen. Die Position wiederspiegelt, wo sich der Inhalt des Fensters
befindet, relativ zur seiner Gesamt-Grösse.

Bevor wir beginnen müssen wir ein paar Entscheidungen treffen bezüglich der
Frage, was unser Fenster anzeigen soll, und wie die Schieber sich darauf auswirken.
Zum Beispiel würden wir bei einem Fenster welches Text anzeigt erwarten, dass
ein Klick auf den Abwärts-Pfeil den Inhalt des Fensters um eine Zeile aufwärts
bewegt. Ein Klick in die Scrollbar unterhalb des Schiebers würde das Display
um eine Seite nach oben verschieben, wobei die aktuell zuunterst sichtbare
Zeile an den oberen Fensterrand wandert. Der vertikale Schieber sollte die
Anzahl angezeigter Zeilen repräsentieren, im Verhältnis zur gesamten Zahl
Textzeilen. Äquivalent würden die horizontalen Pfeile den Text um eine Spalte
seitwärts verschieben.

Demzufolge sind die ersten beiden zu entscheidenden Fragen: Was ist die Grösse
eines vertikalen Schrittes, und was die Grösse eines horizontalen. Für eine
Text-Anzeige sind das die Breite und Höhe eines Text-Zeichens. Für grafische
Inhalte können andere Schrittgrössen sinnvoll sein: Im Sokoban Programm (dazu
später mehr) habe ich entschieden, die Grösse eines angezeigten Feldes als die
Schrittgrösse zu benutzen. Wenn ein Bild angezeigt wird, ist es vielleicht
sinnvoll, ein einzelnes Pixel als Schritt-Grösse zu nutzen.

Diese Schritt-Grösse ist eine wichtige Funktionalität des Fensters: Ich speichere
sie in der +win_data+ Struktur und setze sie beim Erzeugen des Fensters.

Vier andere Informationen sind ebenfalls in +win_data+ enthalten:

. Die Gesamtzahl sichtbarer Zeilen (die vertikale Höhe des Displays)
. The maximale Anzahl Zeichen in einer Zeile (die horizontale Breite des Displays)
. Die _aktuelle_ vertikale Position (die Nummer der ersten sichtbaren Zeile) und
. Die _aktuelle_ horizontale Position (die Nummer des ersten sichtbaren Zeichens).

Diese Grössen-Angaben werden in +win_data+ wie folgt abgelegt:

[source,c]
----
struct win_data {
	int handle; /* Fenster handle */

	int lines_shown; /* Anzahl sichtbarer Zeilen im aktuellen Display */
	int colns_shown; /* Anzahl sichtbarer Spalten im aktuellen Display (längste Zeile) */
	int vert_posn; /* Nummer der ersten sichtbaren Zeile */
	int horz_posn; /* Nummer der ersten sichtbaren Spalte */

	int cell_h; /* Höhe einer Zeichen-Zelle im Fenster */
	int cell_w; /* Breite einer Zeichen-Zelle im Fenster */

	/* VERBLEIBENDE FELDER NICHT ANGEZEIGT */
}
----

Das folgende Diagramm illustriert jedes dieser sechs Felder (das blaue Rechteck
illustriert das angezeigte Fenster zum Hintergrund-Text):

image::images/sliders.png[width=300]

Die Grösse eines Schiebers muss das Verhältnis des tatsächlich sichtbaren Textes gegenüber
der totalen Menge Text anzeigen. In unserem Beispiel hat das Gedicht eine bestimmte Anzahl
Zeilen. Wenn das ganze Gedicht im Fenster angezeigt wird, muss der vertikale Schieber seine
Maximal-Grösse einnehmen - es gibt nichts zu scrollen. Wenn das Fenster jedoch kleiner ist,
so dass nur ein Teil der Zeilen sichtbar ist, muss der Schieber das Verhältnis der Anzahl
sichtbarer Zeilen zur Gesamt-Anzahl Zeilen des Gedichts wiederspiegeln. Sinngemäss gilt dasselbe
auch für den horizontalen Schieber.

Die folgende Funktion gibt eine Zahl von 0 bis 1000 zurück, basierend auf der benötigten
Grösse des Schiebers. Diese Zahl wird berechnet basierend auf der Anzahl verfügbarer Zeilen
(zugelassen durch die Fenster-Grösse) sowie die Zahl der Zeilen bzw. Zeichen, die tatsächlich
sichtbar sind (die vom Zeichnungs-Code angezeigt werden).

[source,c]
----
int slider_size (int num_available, int num_shown) {
	int result;

	/* Falls die angezeigte Zahl kleiner ist als die verfügbare */
	if (num_available >= num_shown) { /* alle sichtbar		   <1> */
		result = 1000; /* also Schieber vollständig */
	} else {
		result = (1000 * (long)num_available) / num_shown;	// <2>
	}

	return result;
}
----
<1> Prüfe, ob das ganze Display ins Fenster passt: Resultat entspricht in dem Falle 1000.
<2> Andernfalls finde den Teil von 1000, mittels long-Multiplikation für höhere Genauigkeit

Die _Position_ des Schiebers hängt von drei Parametern ab: Der Anzahl verfügbarer
Zeilen oder Zeichen, der Anzahl sichtbarer Zeilen / Zeichen, sowie dem aktuellen
Versatz (Offset) von oben bzw. links. Nochmal: Wenn die Anzahl verfügbarer Zeilen
oder Zeichen die der anzuzeigenden überschreitet, ist der Schieber einfach an Position
0 (oben oder links).

Bevor wir das Verhältnis ermitteln müssen wir den "scrollbaren Bereich" berechnen.  Dies
ist die Anzahl von Positionen entlang derer der Schieber bewegt werden kann. Beispiel:
Wenn wir einen Text mit 500 Zeilen haben, und 50 Zeilen auf einmal angezeigt werden können,
kann die erste sichtbare Zeile von Zeile 1 bis 450 reichen: Der scrollbare Bereich für
den vertikalen Schieber ist also 450 Zeilen.

Die Position des Schiebers wird sodann berechnet als 1000 * offset / scrollable_region.

Da der ST keine Fliesskomma-Operationen unterstützt, berechnet der nachfolgende Code
diese Werte mittels Integer-Division und Modulus, und kann überall verwendet werden.

[source,c]
----
int slider_posn (int num_available, int num_shown, int offset) {
	int result;

	/* Falls die angezeigte Zahl kleiner ist als die verfügbare */
	if (num_available >= num_shown) { /* alles sichtbar */
		result = 0; /* also Schieber vollständig, und an oberer Position */
	} else {
		/* Anzahl der Positionen entlang derer der Schieber bewegt werden kann: Muss positiv sein wg. vorherigem Check */
		int scrollable_region = num_shown - num_available;
		int tmp1 = offset / scrollable_region;
		int tmp2 = offset % scrollable_region;

		result = (1000 * (long)tmp1) + ((1000 * (long)tmp2) / scrollable_region);
	}

	return result;
}
----

Mit den beiden obigen Funktionen ist das aktualisieren der Schieber nun eine
einfache Sache. Unsere Funktion ermittelt einfach die verfügbare Anzahl Zeilen
und Spalten basierend auf dem Arbeitsbereich des Screens, danach kann jede
Schieber-Grösse und -Position entsprechend aktualisiert werden. Der Offset des
Schiebers wird gespeichert in +wd->vers_posn+ und +wd->horz_posn+: Diese Felder
werden aktualisiert wenn Events, etwa für das runterschieben um eine Zeile,
verarbeitet werden.

[source,c]
----
void update_sliders (struct win_data * wd) {
	int lines_avail, cols_avail;
	int wrkx, wrky, wrkw, wrkh;

	wind_get (wd->handle, WF_WORKXYWH, &wrkx, &wrky, &wrkw, &wrkh);
	lines_avail = wrkh / wd->cell_h;	// <1>
	cols_avail = wrkw / wd->cell_w;		// <2>

 	/* handle vertical slider 		   <3> */
	wind_set (wd->handle, WF_VSLSIZE, 
		  slider_size (lines_avail, wd->lines_shown), 0, 0, 0);
	wind_set (wd->handle, WF_VSLIDE, 
		  slider_posn (lines_avail, wd->lines_shown, wd->vert_posn), 0, 0, 0);

	/* handle horizontal slider 		   <4> */
	wind_set (wd->handle, WF_HSLSIZE, 
		  slider_size (cols_avail, wd->colns_shown), 0, 0, 0);
	wind_set (wd->handle, WF_HSLIDE, 
		  slider_posn (cols_avail, wd->colns_shown, wd->horz_posn), 0, 0, 0);
}
----
<1> Ermittelt die Anzahl verfügbarer Zeilen zur Anzeige im aktuellen Fenster,
    indem die aktuelle Höhe in Pixeln geteilt wird durch die Anzahl Pixel
    der Höhe einer Zeile.
<2> Ermittelt die Anzahl verfügbarer Spalten zur Anzeige im aktuellen Fenster,
    indem die aktuelle Breite in Pixeln geteilt wird durch die Anzahl Pixel
    der Breite eines Zeichens.
<3> Aktualisiert Grösse und Position des vertikalen Schiebers.
<4> Aktualisiert Grösse und Position des horizontalen Schiebers.

=== Ein Fenster mit Schiebern zeichnen

Es macht keinen Sinn, Schieber zu haben, wenn unser Fenster-Inhalt nicht
auf die Position der Schieber reagiert. Zusätzlich muss unser Zeichnungs-Code
speichern, wieviel Platz horizontal und vertikal vom Inhalt belegt wird,
damit diese Werte genutzt werden können um die Grösse und Position der
Schieber zu errechnen.

Um den vom Inhalt benötigten Platz zu speichern, aktualisiere ich die Anzahl
angezeigter Zeilen jedes Mal wenn eine Zeile gezeigt wird, und die Anzahl
Spalten mit der maximalen Text-Breite.

Aus der vertikalen Schieber-Position ergibt sich die Anzahl zu ignorierender Zeilen,
entsprechend der Position des Schiebers.

Aus der horizontalen Schieber-Position ergibt sich der Offset links von der
Schieber-Position, für das Zeichnen des Textes.

Beachten Sie dass ich mich nicht darum kümmere, dass Text ausserhalb des Screens
gezeichnet wird, da dies vom in +draw_interior+ definierten Clipping geregelt wird.

[source,c]
----
void draw_example (int app_handle, struct win_data * wd, int x, int y, int w, int h) {
	int i = 0;
	int lines_to_ignore = wd->vert_posn;  // <1>
	int cur_y = y + wd->cell_h;           // <2>

	wd->lines_shown = 0;                  // <3>
	wd->colns_shown = 0;                  // <4>

	while (wd->poem[i] != 0) {
		if (lines_to_ignore == 0) {   // <5>
			v_gtext (app_handle, x+wd->cell_w*(1-wd->horz_posn), cur_y, wd->poem[i]);

			if (strlen(wd->poem[i])+2 > wd->colns_shown) {  // <6>
				wd->colns_shown = strlen (wd->poem[i]) + 2;
			}

			cur_y += wd->cell_h;  // <7>
		} else {                      
			lines_to_ignore -= 1; // <8>
		}

		wd->lines_shown += 1;         // <9>

		i = i + 1;
	}

}
----
<1> Wir müssen die Zeilen über der aktuellen vertikalen Schieber-Position weglassen.
<2> Die nächste y Position im Fenster, an der Text angezeigt wird.
<3> Lösche die Anzahl aktuell angezeigter Zeilen.
<4> Lösche die Anzahl aktuell angezeigter Spalten (Breite).
<5> Wenn wir die Zeilen über der aktuellen vertikalen Schieber-position übersprungen
    haben, können wir die nächste Text-Zeile anzeigen
<6> Aktualisiert die aktuelle Anzahl angezeigter Spalten, wenn die aktuelle Zeile breiter ist.
<7> Verschiebt die y Position um eine Zeile nach unten.
<8> Andernfalls reduziere die Anzahl zu ignorierender Zeilen um 1.
<9> Erhöhe die Anzahl angezeigter Zeilen um 1.

Die Anzeige des Fenster-Inhalts hängt von Ihrem Fenster ab. Das obige Beispiel
passt für Text-Zeilen. Für eine grafische Anzeige mag es sinnvoll sein, eine
fixe Grösse für das Fenster zu nutzen, was einige der Berechnungen einfacher macht.

=== Schieber aktualisieren

Die Schieber müssen geprüft und aktualisiert werden, sobald sich die Fenster-Grösse
oder der Inhalt verändern. In der Praxis heisst das, dass wir die Schieber immer
dann ändern, wenn wir den Fenster-Inhalt aktualisieren. Der beste Platz dafür ist
am Ende von +draw_interior+.

[source,c]
----
void draw_interior (struct win_data * wd, GRECT clip) {

	/* REST DER FUNKTION */
	
	set_clip (false, clip);
	update_sliders (wd); 		// <1>
	graf_mouse (M_ON, 0L);
}
----
<1> Ruft die Funktion für das aktualisieren der Schieber-Grösse und -Position
    auf, basierend auf der angepassten Höhe und Breite des angezeigten Inhalts.

Die Schieber müssen ausserdem auch immer dann angepasst werden, wenn sich die
Fenster-Grösse ändern. Das erledigen wir innerhalb von +do_sized+, durch verändern
der +horz_posn+ und +vert_posn+ Werte, so dass sie der neuen Fenster-Grösse entsprechen.
Wenn das Fenster beispielsweise vergrössert wird, kann es mehr Inhalt anzeigen, und
wir können die Anzahl Zeilen über dem oberen Fensterrand reduzieren.

Die Schieber selbst werden automatisch aktualisiert, da das setzen einer neuen
Fenster-Grösse einen REDRAW-Event auslöst, welcher auch die Schieber-Grössen und
-Positionen aktualisiert. Unglücklicherweise passt dieser REDRAW-Event nur zu den
neu sichtbar gemachten Teilen des Fensters: Wenn wir die horizontale oder vertikale
Position verschoben haben, müssen wir den ganzen Inhalt neu zeichnen, und müssen
den REDRAW-Event selber auslösen.

[source,c]
----
void do_sized (struct win_data * wd, int * msg_buf) {
	int new_height, new_width;
	bool changed;				// <1>

	if (msg_buf[6] < MIN_WIDTH) msg_buf[6] = MIN_WIDTH;
	if (msg_buf[7] < MIN_HEIGHT) msg_buf[7] = MIN_HEIGHT;

	// <2>
	new_height = (msg_buf[7] / wd->cell_h) + 1; /* Neue Höhe in Zeichen */
	new_width = (msg_buf[6] / wd->cell_w) + 1;  /* Neue Breite in Zeichen */

	/* Wenn die neue Höhe grösser ist als lines_shown - vert_posn,
	   können wir vert_posn dekrementieren, um mehr Zeilen anzuzeigen. */
	if (new_height > wd->lines_shown - wd->vert_posn) {	// <3>
		wd->vert_posn -= new_height - (wd->lines_shown - wd->vert_posn);
		if (wd->vert_posn < 0) wd->vert_posn = 0;
		changed = true;					// <4>
	}
	/* Wenn die neue Höhe kleiner ist als lines_shown - vert_posn,
	   belassen wir die vertikale Position unverändert, es muss
	   also nichts gemacht werden.                 <5> */

	/* Ähnliches gilt, wenn die neue Breite grösser ist als colns_shown - horz_posn;
	   in dem Falle können wir horz_posn dekrementieren um mehr Spalten anzuzeigen. */
	if (new_width > wd->colns_shown - wd->horz_posn) {	// <6>
		wd->horz_posn -= new_width - (wd->colns_shown - wd->horz_posn);
		if (wd->horz_posn < 0) wd->horz_posn = 0;
	}

	wind_set (wd->handle, WF_CURRXYWH, 			// <7>
		  msg_buf[4], msg_buf[5], msg_buf[6], msg_buf[7]);

	if (changed) {						// <8>
		GRECT rec;
		
		wind_get (wd->handle, WF_WORKXYWH,
			  &rec.g_x, &rec.g_y, &rec.g_w, &rec.g_h);
		do_redraw (wd, &rec);
	}
}
----
<1> Vergleicht ein Flag um festzustellen, ob sich der obere Rand oder die
    Seiten der Anzeige verändert haben.
<2> +new_height+ und +new_width+ sind die Anzahl Zeichen, die vertikal und
    horizontal in der neuen Fenster-Grösse platz haben.
<3> Wenn die Höhe vergrössert wurde, können wir mehr Zeilen anzeigen, und
    so die Anzahl Zeilen über dem oberen Fensterrand verringern.
<4> Setzt das Flag um einen Update auszulösen, wenn der obere Rand des
    Displays bewegt wurde.
<5> Wenn die Höhe reduziert wurde, lassen wir die oberste Zeile wo sie ist.
<6> Äquivalent ändern wir die linke Spalte nur, wenn das Fenster breiter gemacht wurde.
<7> Das setzen der neuen Fenster-Grösse wird einen REDRAW-Event auslösen, wobei
    der neue Teil des Fensters und die Schieber aktualisiert werden, falls nötig.
<8> Löst einen REDRAW des ganzen Fensters aus.

=== Schieber Events

Die Schieber (Slider) können direkt bewegt werden, indem man sie mit der Maus zieht.
Diese Events haben ihren eigenen Message-Typ, einen für den vertikalen und einen für
den horizontalen Schieber. +msg_buf[4]+ enthält die neue Position des Schiebers, als
Zahl zwischen 0 (oben / links) und 1000 (unten / rechts).

[source,c]
----
case WM_VSLID:
	wind_set (msg_buf[3], WF_TOP, 0, 0);	// <1>
	do_vslide (wd, msg_buf[4]);		// <2>
	break;

case WM_HSLID:
	wind_set (msg_buf[3], WF_TOP, 0, 0);
	do_hslide (wd, msg_buf[4]);
	break;
----
<1> Ich hole das Fenster in den Vordergrund, wenn der Schieber bewegt wird.
    In MINT ist es möglich, den Schieber zu packen und zu bewegen und das
    Fenster dabei im Hintergrund zu lassen. Ich denke das ist ein Mangel
    und hole das Fenster darum forciert hervor.
<2> Aufruf des Codes um den Schieber zu handhaben, zusammen mit seiner neuen Position.

Der Code zum aktualisieren des Schiebers setzt voraus, dass wir Änderungen
der ersten Zeile im voraus berechnen. Die neue vertikale Position entspricht
dem Standort der neuen Schieber-Position entlang des scrollbaren Bereichs.

[source,c]
----
void do_vslide (struct win_data * wd, int posn) {
	GRECT r;
	int lines_avail;

	wind_get (wd->handle, WF_WORKXYWH, &r.g_x, &r.g_y, &r.g_w, &r.g_h);
	lines_avail = r.g_h / wd->cell_h; 			// <1>
	wd->vert_posn = (posn * (long)(wd->lines_shown - lines_avail)) / 1000; // <2>
	if (wd->vert_posn < 0) wd->vert_posn = 0;		// <3>
	wind_set (wd->handle, WF_VSLIDE, posn, 0, 0, 0);	// <4>
	do_redraw (wd, &r);					// <5>
}
----
<1> Ermittelt die neue Anzahl verfügbarer Zeilen.
<2> Berechnet die neue vertikale Position im angezeigten Text.
<3> Stellt sicher, dass dies eine gültige Position ist.
<4> Aktualisiert die Position des vertikalen Schiebers.
<5> Zeichnet den Inhalt des Fensters (geschieht nicht automatisch).

Der Code für die Interaktion mit dem horizontalen Schieber ist
im gleichen Stil aufgebaut.

=== ARROW Events

Die verbleibenden Events sind alle als "Pfeil" ("Arrow") Events bekannt: Das
AES schickt der Applikation eine Message dass ein ARROW-Event passiert ist,
und übergibt den Pfeil-Typ in +msg_buf[4]+.

[source,c]
----
case WM_ARROWED:
	wind_set (msg_buf[3], WF_TOP, 0, 0); /* in den Vordergrund bringen   <1> */
	do_arrow (wd, msg_buf[4]);				// <2>
	break;
----
<1> Wie bei den Schiebern bringen wir das Fenster in den Vordergrund, wenn die
    Pfeile benutzt werden.
<2> Aufruf des Pfeil-Handling Codes, mit dem Pfeil-Typ als Parameter.

+do_arrow+ ruft einfach die passende Funktion auf, basierend auf dem Pfeil-Typ.

Es gibt 8 Pfeil-Typen. Jeder Schieber kann entweder ein "Schritt" oder eine "Seite"
in jede Richtung bewegt werden. Die Events für die Pfeile des horizontalen Schiebers
werden auf dieselbe Art behandelt wie die für den vertikalen, abgesehen vom offensichtlichen
Unterschied bei der Ausrichtung. Für den vertikalen Schieber sind die auf- und abwärts
Bewegung wieder dasselbe, abgesehen von kleinen Unterschieden. Ich werde hier nur den
UPLINE Event beschreiben, welcher den Fenster-Inhalt um einen einzelnen Schritt nach
unten bewegt, sowie den UPPAGE Event, welcher den Inhalt um eine ganze Text-Seite
nach unten verschiebt. Wir beginnen mit UPPAGE, dem einfacheren der beiden:

[source,c]
----
/* Diese Funktion wird aufgerufen als Reaktion auf den WA_UPPAGE Pfeil-Typ */
void do_uppage (struct win_data * wd) {
	GRECT r;
	int lines_avail;

	wind_get (wd->handle, WF_WORKXYWH, &r.g_x, &r.g_y, &r.g_w, &r.g_h);
	lines_avail = r.g_h / wd->cell_h;		// <1>
	wd->vert_posn -= lines_avail;			// <2>
	if (wd->vert_posn < 0) wd->vert_posn = 0;	// <3>
	do_redraw (wd, &r);				// <4>
}
----
<1> Berechnet die Menge an verfügbarem Text auf dem Screen in der Vertikalen.
<2> Verändert die vertikale Position um die Text-Menge, die auf dem Screen Platz hat.
<3> Prüft, dass wir nicht zu weit gegangen sind: 0 ist der obere Rand.
<4> Zeichne den Fenster-Inhalt neu.

Theoretisch könnten wir UPLINE gleich behandeln. Statt +wd->vert_posn+ um eine
Text-Seite zu verändern, können wir es nur um 1 verändern. Das einzige ästhetische
Problem damit ist, dass dadurch die Anzeige flackert: Es gibt eine bessere
Technik, die uns weiches Scrolling erlaubt. Diese bessere Technik _kopiert_
den unverändert sichtbaren Teil als Bild um eine Zeile nach unten, und zeichnet
dann nur die neu sichtbare Zeile neu.

Die folgende Funktion benutzt diese bessere Technik. Die ersten vier Zeilen
berechnen den neuen Wert von +vert_posn+ in der gleichen Art und Weise wie
für +do_uppage+. Danach bereiten wir einen Aufruf von +vro_cpyfm+ vor. Diese
VDI-Funktion kopiert Screen-Daten von einer Position zur andern. In pxy[0-3]
legen wir die Lokation des Start-Bereichs ab, und in pxy[4-7] die des Ziel-Bereichs
unserer Kopier-Aktion. Dieser Ziel-Bereich hat die gleiche Position, nur um 1
Text-Zeile nach unten verschoben. Zum Schluss passen wir das Rechteck so an,
dass wir nur den oberen, neu enthüllten Teil des Displays neu zeichnen.

[source,c]
----
/* Diese Funktion wird aufgerufen als Reaktion auf WA_UPLINE Pfeil-Typ */
void do_upline (struct win_data * wd) {
	FDB s, d;
	GRECT r;
	int pxy[8];

	if (wd->vert_posn == 0) return; /* bereits am oberen Rand  <1> */
	wind_get (wd->handle, WF_WORKXYWH, &r.g_x, &r.g_y, &r.g_w, &r.g_h);
	wd->vert_posn -= 1;
	if (wd->vert_posn < 0) wd->vert_posn = 0;

	set_clip (true, r);				// <2>
	graf_mouse (M_OFF, 0L);
	s.fd_addr = 0L;
	d.fd_addr = 0L;
	pxy[0] = r.g_x;					// <3>
	pxy[1] = r.g_y + 1;
	pxy[2] = r.g_x + r.g_w;				// <4>
	pxy[3] = r.g_y + r.g_h - wd->cell_h - 1;
	pxy[4] = r.g_x;					// <5>
	pxy[5] = r.g_y + wd->cell_h + 1;
	pxy[6] = r.g_x + r.g_w;				// <6>
	pxy[7] = r.g_y + r.g_h - 1;
	vro_cpyfm (wd->handle, S_ONLY, pxy, &s, &d);	// <7>

	graf_mouse (M_ON, 0L);				// <8>
	set_clip (false, r);
	
	r.g_h = 2*wd->cell_h; /* zeichne die Höhe von zwei Zeilen am oberen Rand <9> */
	do_redraw (wd, &r);				// <10>
}
----
<1> Wenn wir schon am oberen Rand des Screens sind, gibt es nichts zu tun,
    und wir können die Funktion beenden.
<2> Der Kopiervorgang wirkt sich auf den Screen aus, weshalb wir den
    Clipping-Bereich auf unser Fenster legen, sowie die Maus ausschalten müssen.
<3> Obere linke Ecke des Start-Bereichs.
<4> Untere rechte Ecke des Start-Bereichs, minus eine Reihe.
<5> Obere linke Ecke des Ziel-Bereichs, entspricht dem originalen, um eine Zeile nach unten verschoben.
<6> Untere rechte Ecke des Ziel-Bereichts.
<7> Führt die Kopier-Operation auf dem Screen aus.
<8> Schaltet die Maus ein und deaktiviert den Clipping-Bereich.
<9> Beschränkt das Neuzeichnen auf die obersten zwei Reihen.
<10> Zeichnet den neu enthüllten Display-Bereich neu.

Die oberen zwei Fuktionen werden vier mal wiederholt, für die vier verschiedenen
Bewegungs-Richtungen. Schauen Sie sich den Quellcode an für alle die Varianten,
und auch für +do_arrow+.

=== Beispiel Programm: Version 5

Diese Version beinhaltet alle die für die Behandlung der Schieber notwendigen Funktionen.
Wie man beim Vergleich von Version 4 und 5 sieht, dominiert der Code für die Schieber
das finale Programm: Version 4 hat ungefähr 240 Zeilen Code, wogegen Version 5 in etwa
550 Zeilen besitzt; mehr als doppelt so viele.


== Multi-Fenster Programmierung

Bis jetzt haben wir den Umgang mit einem einzelnen Fenster angeschaut. Die Nutzung
von mehreren Fenstern unterscheidet sich nicht gross, und dank der Struktur die wir
oben benutzt haben, brauchen wir dafür auch relativ wenige Anpassungen im Code.

=== Die Fenster-Liste

Die zentrale Änderung hier ist, dass wir aus der +win_data+ Struktur eine _Liste_
von Instanzen von solchen Strukturen machen. Wir erreichen dies, indem wir ein
zusätzliches einzelnes Feld zu +win_data+ hinzufügen, welches ein Zeiger ist auf
das nächste Fenster in der Liste:

[source,c]
----
struct win_data {
	int handle;	/* Handle der das Fenster identifiziert */
	
	/* ANDERE FELDER */
	
	struct win_data * next; /* Zeiger zum nächsten Listen-Element   <1> */
};
----
<1> Das zusätzliche Feld enthält einen Zeiger auf das nächste Element in der Liste.

Während wir alle die Fenster erzeugen, addieren wir ihre Zeiger zum Ende der
aktuellen Fenster-Liste. In unserem Beispiel erzeuge ich drei Feinster in
+start_program+: Für ein grösseres Programm wäre es vermutlich sinnvoll, dies
in eine separate Fenster-Erzeugungs-Funktion auszulagern.

[source,c]
----
void start_program (void) {
	struct win_data wd1;
	struct win_data wd2;
	struct win_data wd3;
	int dum, fullx, fully, fullw, fullh;

	graf_mouse (ARROW, 0L); /* stellt sicher, dass die Maus ein Pfeil ist */
	wind_get (0, WF_WORKXYWH, &fullx, &fully, &fullw, &fullh);

	/* 1. Das erste Fenster vorbereiten und öffnen */
	wd1.handle = wind_create (NAME|CLOSER|FULLER|MOVER|SIZER, fullx, fully, fullw, fullh);
	wind_set (wd1.handle, WF_NAME, "Example: Version 6 - Blake", 0, 0);
	wind_open (wd1.handle, fullx, fully, 300, 200);
	wd1.poem = poem1;
	wd1.next = NULL;

	wd1.horz_posn = 0;
	wd1.vert_posn = 0;
	vst_point (app_handle, 11, &dum, &dum, &wd1.cell_w, &wd1.cell_h);

	/* Das zweite Fenster vorbereiten und öffnen */
	wd2.handle = wind_create (NAME|CLOSER|FULLER|MOVER|SIZER, fullx, fully, fullw, fullh);
	wind_set (wd2.handle, WF_NAME, "Example: Version 6 - Keats", 0, 0);
	wind_open (wd2.handle, fullx, fully, 300, 200);
	wd2.poem = poem2;
	wd2.next = NULL;
	
	wd2.horz_posn = 0;
	wd2.vert_posn = 0;
	vst_point (app_handle, 11, &dum, &dum, &wd2.cell_w, &wd2.cell_h);

	wd3.horz_posn = 0;
	wd3.vert_posn = 0;
	vst_point (app_handle, 11, &dum, &dum, &wd3.cell_w, &wd3.cell_h);

	/* das zweite Fenster zum Ende der Liste addieren */
	wd1.next = &wd2;				// <1>	
	
	/* Das dritte Fenster vorbereiten und öffnen */
	wd3.handle = wind_create (NAME|CLOSER|FULLER|MOVER|SIZER, fullx, fully, fullw, fullh);
	wind_set (wd3.handle, WF_NAME, "Example: Version 6 - Wordsworth", 0, 0);
	wind_open (wd3.handle, fullx, fully, 300, 200);
	wd3.poem = poem3;
	wd3.next = NULL;
	
	/* das dritte Fenster zum Ende der Liste addieren */
	wd1.next->next = &wd3;				// <2>

	/* 2. Evens für unser Fenster verarbeiten */
	event_loop (&wd1);

	/* 3. Unsere Fenster schliessen und entfernen */
	wind_close (wd1.handle);
	wind_delete (wd1.handle);
	wind_close (wd2.handle);
	wind_delete (wd2.handle);
	wind_close (wd3.handle);
	wind_delete (wd3.handle);
}
----
<1> Benutzt +wd1+ als das erste Listen-Element, also wird +wd2+ daran angehängt.
<2> Hängt +wd3+ als das dritte Element an der Liste an, die mit +wd1+ beginnt.

Wir übergeben nach wie vor den Beginn der Fenster-Liste an den +event_loop+.
Da jetzt aber jeder Event irgendeinem unserer Fenster zugeordnet sein kann,
müssen wir die richtige Instanz von +win_data+ für jeden Event finden. Dies
geschieht in einer eigenen Funktion, mit Hilfe des Fenster-Handles. Die folgende
Funktion geht durch die Liste von +win_data+ Instanzen bis sie eine findet,
deren Fenster-Handle übereinstimmt mit dem Handle des Event-Ziel-Fensters:

[source,c]
----
struct win_data * get_win_data (struct win_data * wd, int handle) {
	while (wd != NULL) {				// <1>
		if (wd->handle == handle) break;	// <2>
		wd = wd->next;				// <3>
	}
	return wd;
}
----
<1> Wiederholt die Suche bis zum Ende der Liste.
<2> Beende die Suche wenn der aktuelle Handle dem Ziel-Handle entspricht.
<3> Geht weiter zum nächsten Fenster in der Liste.

Zum Schluss muss jeder Event, der eine Instanz von +win_data+ braucht, zuerst
die korrekte +win_data+ Struktur finden, basierend auf dem Fenster-Handle, der
den Event ausgelöst hat. Zum Beispiel sieht der REDRAW Event jetzt so aus:

[source,c]
----
case WM_REDRAW:
	do_redraw (get_win_data(wd, msg_buf[3]),  // <1>
		   (GRECT *)&msg_buf[4]);
	break;
----
<1> Findet die +win_data+ Struktur, die mit dem Fenster-Handle des Events korrespondiert.

Der Schliess-Event benötigt etwas spezielle Aufmerksamkeit. In diesem Beispiel
wird durch das Anklicken jeder Schliessbox (jedes Fensters) die Applikation
beendet. Wenn Sie ein dynamischeres System wünschen, in dem Fenster beliebig
geöffnet und geschlossen werden können, müssen Sie den Event abhängig vom
Fenster-Handle behandeln. Schauen Sie sich mein Sokoban Programm, das wir
später besprechen, für ein Beispiel an.

=== Beispiel Programm: Version 6

Version 6 enthält eine Anzeige mit drei sichtbaren Gedichten. Beachten Sie
wie wenige Anpassungen des Quellcodes nötig sind, doch das finale System
ist sehr flexibel: Jedes Fenster kann bewegt, vergrössert oder verkleinert
und separat behandelt werden.


== Die Info Zeile

This is a simple to use part of the GEM window.  The info line can be seen in a 
standard desktop window: it is the strip that says how many bytes and items 
there are in the displayed folder.  

We can easily use an info line in our program.  First, when we create a window, 
we must tell it to include the info line by including +INFO+ in the list of parts.
Second, at any point, we can place some contents into the info line.

We could include an info line for our poem display, to hold the number of lines.
Referring to version 5, we would include +INFO+ in the parts for the 
window.  Then, after the window has beeen created, we can write:

[source,c]
----
	wind_set (wd->handle, WF_INFO, "57 lines");
----

As with the title, you need to have some dedicated storage for the string passed 
to info as GEM will use your pointer and not make a copy.  Length in GEM is 
restricted to 80 characters (although most AES replacements extend this).


== Menus

The menu bar is a convenient way of interacting with our programs.  A menu 
bar is defined within an RSC file, which is a file containing all the 
resources, such as menu bars and dialogs, used by our program.  The RSC 
file is created by an external program: there are several available, but 
I use Resource Master 3.65.  When started, our program must load in its 
RSC file, and access the required information to show menu bars and dialogs.

Menus, in GEM, typically appear at the top of the screen.  The menu bar 
can contain several menus.  Each menu has a title, and can contain a number 
of menu items.  Each menu item may have an associated key command.  Also, 
menu items may be disabled (meaning they cannot be selected), or have a 
check mark showing.  Menus can also contain separator items, which are 
horizontal lines to divide the menu into groups.  The image below 
illustrates these elements:

IMAGE OF MENU

Menus also provide access to the desk accessories.  The convention is that 
the first menu item, on the left, refers to the program name, and contains 
a single item, which opens a dialog showing information about the program.
This first menu item is followed by a separator, and then a list of desk 
accessories (or "Clients" in Mint).

Interactions with the menu are simple: when a menu item is clicked on with 
the mouse, a message is sent to the program indicating that the menu has been 
used.  This message contains information about the menu item that was clicked.

=== The RSC and rsh files

Before our program can use a menu, we need to build the menu in a resource 
construction program (such as Resource Master) and save it as a RSC file.  
Our program also needs a way of associating the clicked on menu item with 
the information sent in the message event.  This information is contained 
in a set of symbol definitions, saved by the resource constructon program 
in a .rsh file (or equivalent).

TIP: It is standard practice to name our .RSC file using the program name.  
Do _not_ use your program name for a .C source file.  For example, if your 
program is 'sokoban', we will have 'sokoban.rsc'.  Do _not_ name one of 
your source files 'sokoban.c'.  ResourceMaster, for example, will export 
a .c file if you choose to build a desk accessory, and this will overwrite 
any source files of the same name.  For safety, only use your program name 
as the .PRG name in your project file, and as the .RSC name.

As we create each menu item, we associate with that menu item a symbol, 
used to name it.  When we export the C header file, we get a file containing
symbol definitions for each menu item.  For Resource Master, the output looks
something like the following.  Note that the symbol 'ABOUT' attached to the 
'About' menu item has been prefixed with the symbol for the main menu itself.

----
 /*  Resource C-Header-file v1.95 for ResourceMaster v2.06&up by ARDISOFT  */

#define MAIN_MENU 0  /* menu 					<1> */
#define MAIN_MENU_ABOUT 9  /* STRING in tree MAIN_MENU 		<2> */
----
<1> The symbol for the main menu itself.
<2> The symbol for the 'About' item on the main menu.

Before we can use the RSC file, we need to include the .rsh file in our 
source code.  We do this by adding a line in "windows.h", for example:

[source,c]
----
#include "version7.rsh"
----

=== Showing a Menu

Before we can show the menu, our program must open the .RSC file.  We must 
check the file has opened successfully before proceeding.  Having done 
this, we can extract the menu bar and show it.  Once our program has 
finished, we should remove the menu bar.  Our +start_program+ function is 
accordingly modified, as follows:

[source,c]
----
void start_program (void) {
	/* DECLARE LOCAL VARIABLES */

	if (!rsrc_load ("\VERSION7.rsc")) {			// <1>
		form_alert (1, "[1][version7 .rsc file missing!][OK]");
	} else {
		OBJECT * menu_addr;				// <2>

		/* 1. install the menu bar */
		rsrc_gaddr (R_TREE, MAIN_MENU, &menu_addr);	// <3>
		menu_bar (menu_addr, true);			// <4>

		/* 2. OPEN WINDOWS ETC */
		
		/* 3. process events for our window */
		event_loop (menu_addr, &wd1);			// <5>

		/* 4. remove the menu bar */
		menu_bar (menu_addr, false);			// <6>
		
		/* 5. CLOSE WINDOWS AND CLEAN UP */
	}
}
----
<1> Attempt to load the RSC file.  If it fails to load, display a dialog, 
    and then abort the program.
<2> Create a local variable to hold the address of the menu.
<3> Retrieve the menu from the RSC data.  We provide the name of the 
    menu +MAIN_MENU+, and the address to store the menu's address.
<4> Display the menu bar for our application.
<5> +menu_addr+ is also passed to the +event_loop+.
<6> Remove the menu bar, which frees up its resources.

NOTE: +rsrc_load+ likes the filename in capital letters preceded with a 
backslash character.

=== Responding to Menu Events

Menu events are passed to our program using the +MN_SELECTED+ event type.
+msg_buf[4]+ contains the reference to the actual menu selected.  These 
references are defined in the .rsh file.

Within the +event_loop+ function switch function, we add the following case
to respond to menu events:

[source,c]
----
	case MN_SELECTED: /* menu selection */
        	do_menu (wd, msg_buf[4]); 			// <1>
		/* return menu to normal */
        	menu_tnormal (menu_addr, msg_buf[3], true);	// <2>
		break;
----
<1> Call out to +do_menu+ with the selected menu item.
<2> Once the menu event has been dealt with, return the menu display to normal.

Notice how GEM highlights the selected menu item whilst the event is carried 
out.  Our program is responsible for returning the item to normal once it has 
finished.

The +do_menu+ function simply dispatches to a function to deal with each 
of the possible menu items.

[source,c]
----
void do_menu (struct win_data * wd, int menu_item) {
	switch (menu_item) {

		case MAIN_MENU_ABOUT:		// <1>
			do_about ();
			break;
	}
}
----
<1> The case statement uses the name for the menu item as defined in the 
    RSC file.

The +do_about+ function displays a simple information dialog - we discuss 
dialogs in a later section.

How about the QUIT option?  When the user selects quit, we don't have to 
do anything except exit the event loop.  This is easily done in the +while+ 
condition:

[source,c]
----
	} while (!(msg_buf[0] == MN_SELECTED && msg_buf[4] == MAIN_MENU_QUIT)); // <1>
----
<1> Loop terminates when it has a +MN_SELECTED+ event which is 'Quit'.

=== Controlling the Menu Items

An individual menu item can be enabled or disabled.  A disabled menu item 
cannot be selected, and is shown greyed out on the menu bar.  Whether a 
menu item is enabled or not is controlled using:

[source,c]
----
menu_ienable (menu_addr, OBJECT, flag);
----

where

* +menu_addr+ is the address of the menu;
* +OBJECT+ is the reference to the menu item; and
* +flag+ is true to enable or false to disable the menu item.

Each menu item can also show an optional check (or 'tick') mark 
beside it.  The code to control this takes the same parameters as 
+menu_ienable+:

[source,c]
----
menu_icheck (menu_addr, OBJECT, flag);
----

Finally, it is possible to change the text showing on a menu item, 
with the call:

[source,c]
----
menu_text (menu_addr, OBJECT, str); // <1>
----
<1> +str+ must be a statically allocated string.  Remember to keep 
    two spaces at the start of the string.

The sample program does not have a good reason to use checked menu items
or to disable items, so there is a menu provided just to try out these 
options.  One menu item controls whether the other is enabled or not, and 
shows a check mark if it is enabled.  For good measure, the altered menu item
also has its text changed.  We store the state for this as 
a global variable, +menu_state+; in a real application the state will likely 
depend on the top-most window's contents, and so be stored within +win_data+.

The action is handled directly in +do_menu+:

[source,c]
----
	case MAIN_MENU_SWITCH:
		menu_state = !menu_state;				// <1>
		menu_icheck (menu_addr, MAIN_MENU_SWITCH, menu_state);	// <2>
		menu_ienable (menu_addr, MAIN_MENU_DUMMY, menu_state);	// <3>
		menu_text (menu_addr, MAIN_MENU_DUMMY, 			// <4>
			   (menu_state ? "  Enabled" : "   Disabled"));
		break;
----
<1> Invert the state.
<2> Set the status of the SWITCH menu item's check sign.
<3> Set the enabled/disabled status of the DUMMY menu item.
<4> Change the text on the DUMMY menu item.


=== Responding to Keyboard Events

This is an appropriate time to extend the range of events we can respond to.
Important menu items should contain keyboard shortcuts, for users who prefer 
not to take their hands from the keyboard.  Keyboard events are sent to our 
program just like other events, but we must listen for them.  To do so, we 
must change our event loop to handle multiple event types.

Any GEM program may produce one or more of a range of different event types.
These include:

* AES messages (as we have handled so far)
* Mouse events: information on the mouse position and which buttons are clicked
* Timer events: an event triggered at regular time intervals
* Keyboard events: triggered when the user types on the keyboard

Although GEM provides separate event listeners for these different types, in 
any real GEM program multiple event types will be needed.  For example, any
GEM program will need to respond to AES messages, mouse events and the 
keyboard, at a minimum; to do this, we use a multiple-event listener.

There are two ways to handle multiple event types.  There is the _traditional_
way, which uses a call to +event_multi+.  This requires setting up several 
internal variables to store any required return values.  AHCC offers an 
alternative way, which uses a call to +EvntMulti+, using a single structure 
to hold all return values.  The advantage of +event_multi+ is conformance 
to previous practice.  The advantage of +EvntMulti+ is a simpler calling 
routine; the AHCC description also claims improved performance.  We shall 
cover both ways.


==== Traditional event_multi

The traditional +event_multi+ function is an extension of the +event_mesag+ 
we have been using so far.  It offers the advantage of being documented in 
the Atari literature, and will be familiar to most programmers.  However, 
it does require care in defining and presenting different reference variables 
to hold various return values.


==== AHCC EvntMulti

AHCC's custom +EvntMulti+ offers the advantage of a simpler calling routine.
Instead of defining separate variables for the possible return values, we 
simply define one instance of +EVENT+, and pass its address to +EvntMulti+.
The return values and the +msgbuf+ are all then stored within our instance 
of +EVENT+.  (The only small downside is that the slot names are not so 
intuitive.)


=== Sample Program: Version 7

In version 7 of the program, we include a menu.  The menu provides an 
'about' dialog, a way to quit the program, and a menu to select which poem 
to show.  

The menu was created in Resource Master, and saved into the RSC file.  The 
C header was exported, creating the .rsh file.  The .rsh file is needed for 
compiling, and the RSC file for running the program.

The 'Quit' option may be triggered via the menu or by keyboard, so this version
uses multiple events in the event loop; two event loops are provided, one 
for the traditional approach, and one using AHCC's custom one.  The 'About' 
option displays a simple dialog box: this uses the built in +form_alert+ call 
to construct a dialog. I explain more about this and dialogs in general in a 
later section.

Finally, this version allows us to open and close poems as we wish.  So the 
window creation code has been changed to allow for a more dynamic set of 
windows, and the window close code has been changed, to only close the selected
window, not exit the program.  The program is only exited with the 'QUIT' 
option.


== Sokoban: A More Complex Example

As a more complex example of multi-window programming, my Sokoban 
implementation may be worth a look.  
The source code is at https://github.com/petercrlane/sokoban

If you review that source code, you will find many things similar to the 
code in this document, however, some things will be different.  This 
document was written, in part, to simplify and unify the code I have 
for GEM handling in my programs, and I haven't put all the
simplifications back.  Also, in a larger application, there are simply 
more things to handle, which add a layer of complexity.

In particular, note how I manage different window types: there is one 
window showing a list of levels, and other windows showing the levels 
in the game.  I have a slot in +win_data+ called +window_type+, and this 
is set to +LEVELS+ or +POSITION+ when the window is created.  Within 
+draw_interior+ I now switch to the appropriate calling code, depending 
on the window type.

Additionally, in some situations, such as when a move is made, not all 
of the window needs to be redrawn.  I also have a flag for the type of 
update: when a move is made, this flag is +MOVE+.  The drawing code for 
the position will then only update the parts of the window related to that 
last move.  Such refinements are necessary to prevent your application 
flickering too much, due to constant updates.

Sokoban also provides an example of +evnt_multi+, as the program responds 
to window events, as above, but also mouse and keyboard events.  


== File Selectors

In this section we look at the file selector dialog.  This is an important 
and useful dialog, enabling the user to select a filename to save or open.

=== Sample Program: Version 8

Version 8 of the program now includes options to save or open a file stored 
on disk as a text file.  


== Dialogs

something about dialogs

=== Form Alerts

built in dialogs

=== Through RSC

boxes you build yourself

=== Sample Program: Temperature Converter

This sample program is a standalone program.  It provides a simple 
dialog which converts temperatures from fahrenheit to celsius.  It 
illustrates how to access information in text fields, and how to 
respond to button clicks.


For an example of using dialogs within a larger program, the 
BibFind program may be of interest.  This provides a 'Find' dialog 
box, which returns a string to search to the calling program.
BibFind source code is available at https://github.com/petercrlane/bibfind


== Selected Features of TOS 4.0+

So far, I have kept my treatment of GEM programming at a level which 
would suit all Atari GEM platforms, from the Atari ST running 
TOS 1.04 to powerful clones such as the Firebee running Mint/XaAES.  
The later versions of AES do, however, support additional events and features 
which are worth including in your programs, if you wish them to run on the 
more powerful systems.  

TIP: Some of these features also only work with certain versions of AES, 
e.g. XaAES or MyAES.  You should consult documentation specific to your 
target platform before using any of the following.  A call to +appl_getinfo+ 
can be used within your program to determine what features are available.
Refer to toshyp for further details.

=== Additional Events

This list is a very incomplete summary of some events I have started 
including in my GEM programs:

1. Shading: Shading is where the window is collapsed into its title bar.
   On Mint/XaAES this is achieved by right- or double-clicking the title
   bar.  When shaded, windows should not redraw themselves or respond to 
   keyboard events.  One way to handle this is to:
   
** include a flag +shaded+ in +win_data+
** set this flag to true when receiving the message +WM_SHADED+
** set this flag to false when receiving the message +WM_UNSHADED+
** in +draw_interior+, simply return if +wd->shaded+ is true, before drawing anything
   
2. AP_TERM: this message is sent to tell your application to quit.  You 
   can handle this in the event loop, by checking that +msg_buf[3] != AP_TERM+
   in the condition of the do-while loop.
   
3. WM_ONTOP: If another window is closed which leaves your window on top, this 
   message is sent to your application.  This is useful in circumstances when 
   you want to update some displayed information based on the current top 
   window.  (Sokoban uses this to update enabled menu items for the current
   top window.)

4. WM_BOTTOMED: A single click on the window title in Mint/XaAES sends 
   the window back in the window list.  To support this, include the following 
   code in event loop, within the switch statement of message types:
   
[source,c]
----
case WM_BOTTOMED:
	wind_set (msg_buf[3], WF_BOTTOM, 0, 0, 0, 0); // <1>
	break;
----
<1> Set the given window handle to the bottom.

=== Toolbars

Using some widgets in a toolbar.

[source,c]
----
wind_set(window_handle, WF_TOOLBAR, toolbar_object);
----

Events are of type +WM_TOOLBAR+.

Care is needed to account for toolbar when calculating window work areas.

=== Internal Menus

Menus within a window.  Supported in XaAES only.

[source,c]
----
wind_set (window_handle, WF_MENU, menu_address);
----

== Scrap Library

The scrap library is GEM's answer to the cross-application clipboard. 

First the bad news: many Atari programs do not use the GEM scrap board.
For example, some word processors such as Marcel and Protext use their 
own custom clipboards, and so do not support copy and pasting information 
to or from other applications.  This is also true of our favourite IDE, AHCC.

Second, the even worse news: as with most features of GEM, the scrap library 
leaves _everything_ to the programmer.  The scrap library is nothing more 
than a file stored in a known folder.  This folder is identified by calling
+scrap_read+, which retrieves the current scrap folder.  In addition, as 
different desktop environments may provide paths to the scrap library/clipboard,
we need to check for these.  If there is no current scrap folder, then our 
program must create it.  

Once the scrap folder is located, we either read from a file named "SCRAP", 
if we are, for example, pasting the last piece of copied information.  
Alternative, we may write to a file named "SCRAP" if we are copying some 
information.  The file extension for the "SCRAP" file is set appropriate 
to the data we are saving, e.g. ".TXT" for text data.  When writing a 
file, we need to first delete any existing files named "SCRAP.*" in the 
scrap folder.

One final refinement: if we save a file into the scrap folder, we should 
let other applications and the desktop know, so they can update their 
displays or information about the scrap library.

=== Using the scrap library

I will simply give two functions here, which firstly find the location of 
the scrap folder, and secondly update any other users of the scrap folder 
when we have changed it.

The following function requires a reference to some allocated space, and 
will place into that space a full path name to a file "SCRAP.TXT" in the 
scrap folder.  If the scrap folder does not already exist, it will be 
created.

[source,c]
----
void get_clipboard_file (char * scrap_path) {
	char * env_scrap_path = NULL;
	char dirname[PATH_MAX];
	struct ffblk * cur_file;

	/* check possible environment variables 		   <1> */
	shel_envrn (&env_scrap_path, "CLIPBOARD=");
	if (env_scrap_path == NULL) {
		shel_envrn (&env_scrap_path, "CLIPBRD=");
	}
	if (env_scrap_path == NULL) {
		shel_envrn (&env_scrap_path, "SCRAPDIR=");
	}

	if (env_scrap_path == NULL) {
		/* if not found, use the scrap_path result */
		scrp_read (scrap_path);				// <2>
	} else {
		/* copy env_scrap_path into scrap_path */
		strcpy (scrap_path, env_scrap_path);		// <3>
	}

	/* check we have a valid path, adding \ to end if needed */
	if (scrap_path[strlen(scrap_path)-1] != '\\') {
		if (strlen(scrap_path) < PATH_MAX - 2) {
			int end = strlen(scrap_path)-1;
			scrap_path[end] = '\\';
			scrap_path[end+1] = 0;
		}
	}

	/* set up clipboard folder if one does not exist 	   <4> */
	if (strlen (scrap_path) == 0) {
		int curr_drive = Dgetdrv ();
		/* cannot modify an in-place string, so copy it:
		   this caused a strange error, where menu would not
		   reappear when re-focussing the application.
		 */
		char * folder = strdup("A:\\CLIPBRD\\");

		folder[0] += curr_drive; /* set to current drive */
		Dcreate (folder);        /* make sure it exists 	<5> */	
		scrp_write (folder);     /* write the clipboard folder 	<6> */
		scrp_read (scrap_path);  /* read it back in */
		free (folder);
	}

	/* delete any SCRAP.* files currently in the scrap directory */
	strcpy (dirname, scrap_path);
	strcat (dirname, "SCRAP.*");
	if (findfirst (dirname, cur_file, 664) == 0) {		// <7>
		do {
			char * filename = malloc (sizeof(char) * PATH_MAX);
			if (strcmp (cur_file->ff_name, ".") == 0) continue;
			if (strcmp (cur_file->ff_name, "..") == 0) continue;
			strcpy (filename, scrap_path);
			strcat (filename, cur_file->ff_name);
			remove (filename);
		} while (findnext (cur_file) == 0);
	}
	/* Write data as plain text */
	strcat (scrap_path, "SCRAP.TXT");			// <8>
}
----
<1> First, look in some standard environment variables for an existing 
    path to a clipboard.
<2> If one is not found, use +scrap_read+ to see if GEM already has a 
    record of the scrap folder.
<3> If one was found, use that one by copying it to +scrap_path+.
<4> If no existing path has been found, then we need to create the 
    scrap folder.
<5> Create folder "CLIPBRD" in the current drive.
<6> And set it as the scrap folder using +scrap_write+, reading this 
    back into +scrap_path+ using +scrap_read+.
<7> Use +findfirst+ and +findnext+ to loop through all the "SCRAP.*" files 
    existing in the scrap folder, to delete them.
<8> Finally, append the name of the scrap file to the path.

The following code can be used to update the clipboard observers, given 
the path of the scrap folder.  The message types and +appl_search+ 
functions are only suitable for later versions of TOS 4.0+, so don't use 
this function on TOS 2.06 or earlier on your Atari ST.

[source,c]
----
void update_clipboard_observers (char * path) {
	short msg[8] = {0, 0, 0, 0, 0, 0, 0, 0};
	char name[PATH_MAX];
	int id, type;

	if (strlen(path) < 3) return; /* if too short to be a path */

	/* update desktop 					<1> */
	msg[0] = SH_WDRAW;
	msg[1] = app_handle;
	msg[3] = toupper(path[0]) - 'A';		      // <2>
	if (appl_search (APP_DESK, name, &type, &id) == 1) {  // <3>
		appl_write (id, 0, msg);		      // <4>
	}

	/* inform other applications 				<5> */
	msg[0] = SC_CHANGED;
	msg[3] = 0x0002; /* updated a text file */
	if (appl_search (APP_FIRST, name, &type, &id) == 1) { // <6>
		do {
			appl_write (id, 0, msg);	      // <7>
		} while (appl_search (APP_NEXT, name, &type, &id) == 1); // <8>
	}
}
----
<1> If the desktop is showing the scrap folder, then we want it to refresh
    its display.  
<2> The third argument gives the drive number: 0 is A, 2 is C etc.
<3> Finds the id reference for the desktop.
<4> Sends the desktop the message to update its display of the given drive.
<5> Other applications may be dealing with the scrap folder, so we let them 
    know the scrap folder has changed.
<6> Use +appl_search+ to locate the first application.
<7> Send the message to the current application.
<8> Loop with the next application, until all applications have been called.

=== Examples

Of my own programs, only BibFind uses the scrap library: http://peterlane.info/bibfind.html

For a sophisticated use of the scrap library, see GEMClip:

[appendix]
== License

This guide is copyright (c) 2016, Peter Lane, and is provided under 
version 0.9.4 of the http://owl.apotheon.org/[Open Works License]

Permission is hereby granted by the holder(s) of copyright or other legal
privileges, author(s) or assembler(s), and contributor(s) of this work, to any
person who obtains a copy of this work in any form, to reproduce, modify,
distribute, publish, sell, sublicense, use, and/or otherwise deal in the
licensed material without restriction, provided the following conditions are
met:

Redistributions, modified or unmodified, in whole or in part, must retain
applicable copyright and other legal privilege notices, the above license
notice, these conditions, and the following disclaimer.

NO WARRANTY OF ANY KIND IS IMPLIED BY, OR SHOULD BE INFERRED FROM, THIS LICENSE
OR THE ACT OF DISTRIBUTION UNDER THE TERMS OF THIS LICENSE, INCLUDING BUT NOT
LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS, ASSEMBLERS, OR HOLDERS OF
COPYRIGHT OR OTHER LEGAL PRIVILEGE BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER
LIABILITY, WHETHER IN ACTION OF CONTRACT, TORT, OR OTHERWISE ARISING FROM, OUT
OF, OR IN CONNECTION WITH THE WORK OR THE USE OF OR OTHER DEALINGS IN THE WORK.


